<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Express</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <nav class="navExpress">   
                <li> <a href="#template"> Template Engine </a></li>
                <li> <a href="#sql"> MySQL</a></li>
                <li><a href="#sequelize"> Sequelize</a></li>
                <li><a href="#mvc">Arquitetura MVC</a></li>
                <li><a href="#api"> API</a></li>
        </nav>
        <h1> Express </h1>
        <h2> O que é o Express ?</h2>
        <p> Express é um framework para NodeJS utilizado no BackEnd. Ele serve para criarmos aplicações WEB, tanto estáticas quanto dinâmicas com BD, Autenticações, etc. Ele acaba dominando o mercado de NODEJS, onde iremos aprender a criar rotas, aprender sobre arquiteturas (MVC), separar o front do back (API'S), entre diversas outras utilidades. É um framework leve e relativamente de ser utilizado. O Express torna a criação de apps muito mais simplificadas do que utilizando os Core Modules, pois uma série de coisas que criamos na mão antes, aqui é criado "automaticamente". Para instalar o express em um projeto,  primeiro utilizamos o comando <span>npm init - y </span> e em seguida instalar o pacote do Express <span>npm install express</span>.</p>
        <h2> Rotas </h2>
        <p> Rota  é um conceito super importante e presente em qualquer aplicação WEB. Rotas são básicamente os caminhos, as URL's que acessamos. Se acessarmos um site www.teste.com/produtos, esse /produtos é uma rota do nosso site. Vale ressaltar que uma url sem a barra, também é uma rota, a HOME, que dependendo do projeto, já executa alguma coisa. Rotas estão sempre ligadas a alguma funcionalidade da nossa aplicação. Quando acessamos alguma rota podemos acessar várias lógicas, como nesse exemplo acima, carregar a lista de produtos vindas do banco de dados. Em resumo, rotas são uma ponte entre o usuário e a lógica da aplicação. Uma rota não necessáriamente irá fazer uma coisa apenas, dependendo do seu verbo (Put,Delete,Remove,Update), pode fazer até 04 coisas, que é o famoso CRUD.</p>
        <h2> Setup Inicial </h2>
        <p> Antes de startarmos o Express, vale ressaltar mais uma vez que a WEB funciona com requisicoes e respostas. REQ é onde o usuário envia os dados de um formulário por exemplo para o servidor. E na RES é quando o servidor envia uma resposta para o usuário. Relembrando isso, podemos iniciar o express. O setup inicial do express é simples, mas precisamos saber alguns passos.</p>
        <ul>
            <li>Importar o Express e Invocá-lo</li>
            <li>Definir uma porta base para a aplicação</li>
            <li>Criar uma rota (URL que será acessada)</li>
            <li> Executar o método listen na porta especificada.</li>
        </ul>
        <p> Abaixo segue um exemplo simples do Express funcionando o passo a passo citado acima. </p>
        <img src="../../img/express/firstExpress.jpg" alt="" class="teste">
        <h2> Renderizando HTML</h2>
        <p> No exemplo acima, ao acessarmos a rota desejada ela nos responde apenas uma mensagem de texto, no caso 'Olá Mundo', que acaba sendo algo pouco útil no dia a dia. Dando continuidade, aqui aprenderemos a renderizar HTML como resposta usando o Express. Para isso utilizaremos o método SendFile, fazendo com que o arquivo seja renderizado no navegador. Para isso precisamos acessar o arquivo por meio do diretório base, e isso requer o módulo PATH. </p>
        <p> Por padrão colocamos nossos arquivos HTML em uma pasta chamada TEMPLATES. Utilizando o método path, pegamos nosso diretório atual (__dirname), e juntamos com o da pasta desejada (templates), assim teremos a localização precisa de onde estará nossos arquivos HTML. Em seguida basta enviarmos. Exemplo abaixo: </p>
        <img src="../../img/express/expressHtml.jpg" alt="">
        <p> Nesse exemplo contamos com a ajuda do PATH, porém futuramente aprenderemos outra forma mais simples de aplicar essa sintaxe. </p>
        <h2> Problemas de Atualização</h2>
        <p> Quando começamos a trabalhar com Express, podemos reparar que a cada atualização feita em nosso projeto precisamos parar o servidor (ctrl + c), e iniciar denovo para que as atualizações sejam vistas. Para solucionar isso contaremos com o módulo Nodemon, que a cada vez que o arquivo é salvo ele reinicia o projeto de forma automática, facilitando consideravelmente o workflow com Express. Para isso, salvamos ele como dependência de desenvolvimento, e acaba sendo uma boa prática para praticamente todos os projetos utilizando node. Para isso, utilziar o comando <span> npm install --save-dev nodemon</span>.</p>
        <p> Após  instalado, nós não podemos mais iniciar o projeto com o comando node index.js por exemplo, pois ele não estará utilizando o nodemon, e sim startar pelo nodemon. Para isso, é de boa prática irmos nos scripts do NPM dentro da pasta packaged.json, e colocar o nodemon junto ao comando start, para que sempre que dermos um npm start, ele já abra com o nodemon automáticamente. Exemplo abaixo. Ou voce pode simplesmente startar o projeto com o comando <span>nodemon index.js</span>.</p>
        <img src="../../img/express/nodemon.jpg" alt="">
        <h2> MiddleWares </h2>
        <p> É mais um conceito que junto as rotas, estarão presente o tempo inteior quando trabalhamos com NodeJS. Middlewares são códigos que podem ser executos no meio/entre alguma ação e outra. Um exemplo prático é verificar se o usuário está logado. Por exemplo, um usuário tenta acessar uma rota em específico na qual apenas usuários autênticados possuem acesso. Nesse momento colocamos um middleware(algo que será executado entre a req do usuário e a res) e aqui se vermos que ele está logado prossegue e se não tiver, vá embora. </p>
        <p> O método que nos da acesso a utilizar middlewares no express é o Use. Futuramente iremos aprender a utilizar os middlawares para rotas individualmente, o que trará mais sentido, pois na maioria das vezes iremos querer ver se o usuário está logado por exemplo em apenas algumas das rotas e em outras não, mas fica para o futuro. Abaixo segue um exemplo de um middleware simples funcionando para toda a aplicação: </p>
        <img src="../../img/express/middl.jpg" alt="">
        <p> Vale ressaltar que os middlewares sempre precisarão utilizar o método NEXT como mostrado acima, para assim que ele realizar sua função seja ela qual for, ele redirecionar para o next(Seuginte). </p>
        <h2> Parâmetros via URL.</h2>
        <p> Ao falarmos de requisições, elas podem enviar dados que podem vir básicamente pelo método GET ou pelo método POST. Devido a isso, podemos resgatar os parâmetros da URL por meio do REQ. Acessamos req.params.nome onde o nome deve ser o que está definido na URL do Express. Dessa forma por exemplo, fica dessa forma: /users:id por exemplo. Neste caso , estaríamos buscando o usuário no banco de dados pelo ID. </p>
        <p> No exemplo abaixo mostramos uma rota que recebe um ID por parâmetro da URL e atribuimos esse id para uma variável. Em seguida, poderemos fazer qualquer coisa com essa informação como por exemplo uma consulta no banco de dados onde ele irá retornar o usuário com o id em questão. </p>
        <img src="../../img/express/params.jpg" alt="">
        <h2> Parâmetros via POST</h2>
        <p> Post é quando enviamos algo através de um usuário, geralmente na intenção de inserir informações em algum banco de dados. Para enviar os dados é necessário criar um form e enviar os dados via POST. No express é necessário colocar alguns midwares como o express.json, para ler os dados do body. E também uma rota qeu vai receber estes dados, utilizando o método post do express.  Básicamente o fluxo é : O usuário preenche o form e envia. O servidor(Express), recebe a solicitação para a rota desejada, o middleware entra no meio e trata os dados e em seguida redireciona para a rota para enfim realizar a ação necessária.</p>
        <p> Quando recebemos os dados via POST, </p>
        <img src="../../img/express/post.jpg" alt="">
        <h2> Módulos de Rotas: </h2>
        <p> É possível unir várias rotas em um módulo, isso vai deixar nosso código mais organizado. Muitas vezes iremos ter diversas rotas para diversas entidades, como usuário, produtos, compras, e isso acaba deixando a aplicação bagunçada e ilegível. Para isso normalmente é criado uma pasta para cada entidade em comum, como users por exemplo. Dentro da pasta User criamos um arquivo index.js onde criaremos as rotas dos users. Para isso vamos utilizar um novo objeto chamado Router. Depois precisamos exporta-lo e importa-lo no arquivo principal.  </p>
        <p> No arquivo index dentro da pasta Router, fica assim:</p>
        <img src="../../img/express/userRout.jpg" alt="">
        <p> Lembrar que no final precisa exportar <span>module.exports = router</span></p>
        <p> E dentro da aplicação principal, é preciso importar esse Router exportado: </p>
        <p style="color: red;"> falta fazer</p>
        <h2> Css com Express </h2>
        <p> Para inserir CSS nas páginas e arquivos estáticas vamos precisar de um middleware, que é o express.static. Precisamos colocar um diretório base, que normalmente é o public e em seguida criar os estáticos a partir desta pasta. No html podemos acessar o caminho relativo após a pasta estar definida e pronto. Linha para colocar no App principal:  </p>
        <img src="../../img/express/cssjs.jpg" alt="">
        <h2> Pag 404</h2>
        <p> Em todo projeto é necessário criar uma página 404 em caso de o usuário digitar um URL não existente ou qualqeur outro tipo de erro. Ela é usada quando o usuário tenta logar em uma página não encontrada. Basta criar um novo middleware abaixo de todas as rotas, que responde com este status, e enviar um arquivo de template diferente a esta página. Veremos na prática:</p>
        <img src="../../img/express/404.jpg" alt="">
        <h1 id="template"> Template Engines </h1>
        <p>Template Engine é um motor de Templates, um motor de HTML. Ele dá funcionalidades e recursos as views. Agora temos a possibilidade de receber dados e injeta-los em nossas views. É uma forma de deixar nosso html dinâmico. É uma forma de inserir variáveis do back para o front end. Podemos utilizar layouts que são reaproveitáveis, não será necessário repetir tanto código html. É essencial para projetos que usam banco de dados. Temos diversos disponíveis como EJS, PUG, HandleBars. Todos atingem o mesmo objetivo porém há algumas diferenças de setup e funcionalidades. Aqui utilizaremos o handlebars, que tem como prática o minimo possível de código na view, deixando o código um pouco mais trabalhoso, porém mais limpo. Dentro da programação web muito será falado em separar as responsabilidades. A parte de front-end deve ser apenas para exibir o que tem que ser exibido e não ser responsável por muita lógica de programação.</p>
        <p> Aprendendo a trabalhar com um, será muito fácil de aprender com todos e migrar para qual mais lhe agradar. Mas, o que é HandleBars ?</p>
        <h2> HandleBars</h2>
        <p> O handlebars é uma das template engines mais utilizadas no universo do Node. Colocamos os dados dinâmicos no HTML entre {{}} para serem impressos(imprimir variáveis). Podemos criar condicionais e também loops dentro do template. O handlebars é conhecido pela sua sintaxe limpa no front, nos forçando a não executar lógica de programação dentro dos templates. </p>
        <p> O nome do pacote é express-handlebars, comando: <span>npm install npm-handlebars</span>. O handle-bars não é algo exclusivo do NODEJS, pode ser utilizado em outras linguagens. No nosso caso, utilizamos a express-handlebars, que é uma handlebars adaptada para o Node.</p>
        <p> Assim como vimos no Express, o passo a passo para instalar o handlebars: </p>
        <ul>
            <li>Instalar o Nodemon, Express e o HandleBars</li>
            <li>Importar os pacotes instalados.</li>
            <li>Adicionar o express a engine do HandleBars</li>
            <li> Criar uma view com a extensão handlebars</li>
            <li> Método Render para enviar esta view para a requisição(diferente do sendFile).</li>
        </ul>
        <p> Segue abaixo a foto do setup:</p>
        <img src="../../img/express/handlebar.jpg" alt="">
        <p> Como boas práticas, colocamos sempre os arquivos html ( no caso .handlebars), dentro de uma pasta <span>View</span>.</p>
        <h3> Layouts</h3>
        <p> Uma das grandes sacadas de usar template engines, além de tornar a aplicação dinâmica, é o fato de podermos criar layouts para reaproveitar código entre páginas.Dentro de Views criamos uma pasta chamada <span>Layout</span> onde nela criaremos o template que será repetido e utilizado por padrão. Para isso utilizamos a tag especial <span>{{{body}}}</span> que é o miolo da página, a parte que muda, é aqui que toda a informação será muidada. A partir desse momento, todas as nossas views o layout será repetido. A partir desse momento, todas as "páginas" de .handlebar não precisam mais ter a p </p>
        <p style="color: darkcyan;"> OBS: Nas configurações do projeto, mudar layout false, para layout TRUE, ou simplesmente apagar.</p>
        <h2> Dados para a View. </h2>
        <p> Aqui realmente aprenderemos a deixar nossas páginas dinâmicas. Vamos passar os dados por meio do método Render. Enviamos um objeto com chaves e valores, e isso nos possibilita acessar estes dados dentro do template. Para isso, utilizamos a sintaxe <span>{{dados}} </span>e o dado em si será impresso. Dentro da rota, fazemos a regra para enviarmos para a view. Exemplo: </p>
        <img src="../../img/express/enviarvIEW.jpg" alt="">      
        <p> Desta forma dentro da View já podemos utilizar a variavel user, como no exemplo: </p>  
        <img src="../../img/express/viewDinamic.jpg" alt="">
        <h3> Condicionais</h3>
        <p> Da mesma forma que podemos imprimir agora variáveis dentro das views, também podemos executar condicionais dentro delas. Utilzar condicionais nos permite mais flexibilidade no layout. A sintaxe é : <span> {{#if algumacoisa}}</span> ... <span>{{/if}}</span>. Ela só imprime o que está entre as condicionais caso o dado seja verdadeiro. Precisamos encaminhar o dado a ser validado pelo BackEnd. Aqui que o handlebars começa a dificultar a vida, pois como não possui regra no front, tudo precisa ser feito no backend e enviado de forma mastigada para o front(Apesar de gerar dificuldade no início, é uma boa prática).</p>
        <p> No exemplo abaixo, a parte do voce esta autenticado... só será renderizado caso a variavel Auth enviada pelo backend seja True. Caso seja false, nada aparecerá.</p>
        <img src="../../img/express/ifHandle.jpg" alt="">
        <p> Assim como possuímos o IF, também temos o ELSE. O else é um complemento do IF. Utilizamos no Handlebars para a exibição de outra parte do layout (caso a condição seja falsa). Isso nos dá mais flexibilidade ainda. a sintaxe é: <span> {{#if algumacoisa}}</span> ... <span>{{else}}</span> ... <span> {{#/if}}</span> . Dessa forma, tudo o que está entre o else e o fechamento do if, só será renderizado caso o IF seja falso. </p> 
        <h3> Repetição</h3>
        <p>As estruturas de repetição no handlebars são feitas pelo operador EACH. A sintaxe é <span> {{{#each}} </span> ... <span> {{/each}}</span>. Em um array podemos chamar os itens com {{this}. Então cada um dos itens é acessado na view. Vale lembrar, como o Handlebars prega um tempalte mais limpo, devemos mandar apenas o necessário para o front. Não será possível por exemplo filtrar uma lista dentro das Views. </p>
        <p> Por exemplo, ao enviarmos uma lista do back para o front, podemos iterar sob essa lista para renderiza-la, como no exemplo abaixo:  </p>
        <img src="../../img/express/repHandle.jpg" alt="">
        <h3> Utilizando o With.</h3>
        <p> O with nos permite abstrair o objeto, ou seja, nos permite deixar ele mais simples. Por exemplo, ao enviarmos um objeto USER do back para o frotn, ao inves de ficarmos digitando user.name, user.age, user.email, com o WITH podemos simplifica-lo, e digitar apenas suas propriedades sem nos referenciarmos ao objeto antes. Sintaxe: <span> {{#with objeto}}</span> ... <span>{{/with}}</span>. Desta maneira nosso código fica ainda mais limpo. Muito útil quando nos deparamos com objetos grandes. Exemplo abaixo: </p>
        <img src="../../img/express/withHandle.jpg" alt="">
        <h3> Partials</h3>
        <p> O partials funciona como mini templates que precisam ser repetidos em diversos locais da nossa aplicação. Por exemplo, em um ecommerce, um produto aparece dentro de um card, que se repetem diversas vezes (quando procura, quando vai comprar,etc). Através do partials, podemos criar esses templates menores(como o do cards de produtos),para serem renderizados dentro do template maior(Muito semelhante aos componentes do React). Para funcionar, precisamos realizar algumas modificações na implementação do handlebars. Os partials geralmente ficam em views/partials. E utilizamos a sintaxe <span> {{>partial}}</span> para chama-lo no projeto. </p>
        <p style="color: red;">Falta Coisa</p>
        <h2> Css com HandleBars. </h2>
        <p> A inclusão do CSS no handleBars é muito semelhante a que realizamos com o CSS. Precisamos definir a pasta dos arquivos estáticos (public), e assim linkar o css com nosso layout em comum para todas as páginas. Isso tonra possivel estilizar os nossos projetos.</p>
        <p> primeiramente configuramos o projeto para receber CSS, com o middleware, da mesma forma que vimos lá encima. </p>
        <img src="../../img/express/cssHandle.jpg" alt="">
        <p> Agora basta criar a pasta public => css => styles.css.</p>
        <h1 id="sql"> Integrando MySQL</h1>
        <h1 id="sequelize"> Sequilize </h1>
        <h1 id="mvc"> Arquitetura MVC</h1>
        <h1 id="api">API</h1>
        
    </main>
</body>
</html>