<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> TypeScript </title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <h1> TypeScript </h1>
        <h2> O que é o TypeScript ?</h2>
        <p> Typescript é uma linguagem de programação feita pela Microsoft, porém ela é código aberto. É uma linguagem feita 100% baseada no Javascript. O typescript não funciona no navegador, ele sempre precisará ser convertido para javascript para funcionar. O TypeScript ão veio para substituir o JavaScript ou para fazer outra coisa que o javascript não faça. Tudo que fazemos com o TypeScript também é possível fazer com o JavaScript. Mas então porque usa-lo ? </p>
        <p> O <span>TypeScript</span> veio como uma forma de você criar um código melhor. Com o TypeScript é possível prever erros que podem vir a acontecer no futuro. É um código mais seguro, um código que voce sabe qual será o resultado final, um código livre de pequenos errinhos. É um código <span>Tipado</span>. Aqui iremos definir tipos para variáveis, funções etc. Talvez em um primeiro momento se torne algo mais "trabalhoso", "complicado", porém com o tempo você verá que ele irá assegurar o código e até mesmo facilitar quando o código ficar "maior". </p>
        <p style="text-align: center;"><span> TypeScript é um JavaScript "tipado" </span></p>
        <h2> Instalando o TypeScript </h2>
        <p> Para instalarmos o TypeScript podemos acessar o próprio <a href="https://www.typescriptlang.org/">site do TS</a> e lá conferirmos as alternativas de instalação, pois podemos instalar o TS apenas no projeto, o TS globalmente (Instalará no computador e funcionará em qualquer projeto). Para instalarmos o TypeScript é necessário que o node esteja instalado, para que possamos instalar o typescript via NPM com o comando: <span> npm install -g typescript </span> </p>
        <p><span>Regra 01:</span> Dentro do HTML voce nunca importa um arquivo TS. Voce importa ele JS e depois via comando ele é convertido. </p>
        <p> Regra 02: Entrar dentro da pasta do projeto (terminal do VSCODE) e digitar o comando do TS: <span>tsc nomeDoArquivo.ts</span>. Logo em seguida ele irá gerar um arquivo JS, e irá "funcionar".  </p>
        <p> Mesmo que haja error dentro do arquivo TS, ele irá converter para html. Por boas práticas é necessário evitar isso. Comando: <span> tsc nomedoprojeto.ts --noEmitOnError</span>. Dessa forma o arquivo JS não será gerado caso exista erros na aplicação.</p>
        <h2> Types Primitivos.</h2>
        <p> Aqui começamos a realmente entrar dentro do universo typescript e suas principais typagens. As typagens primitivas são basicamente três. No JS quando queremos criar uma <span>VARIAVEL</span>, colocamos: </p>
        <ul>
            <li> let/const/var nome = 'Guilherme'</li>
        </ul>
        <p> Já no typescript precisamos typar o que ela está eseprando, ex: </p>
        <ul>
            <li>let nome: string = 'Guilherme'</li>
            <li>let idade: number = 30 </li>
            <li>let trueOrFalse: boolean = true</li>
        </ul>
        <p> Quando trabalhamos com TS o editor é o seu melhor amigo, pois ao você typar uma variável com number, ele irá acusar o erro caso você atribua a seu valor uma string.</p>
        <h2> Types em Arrays</h2>
        <p> Para tiparmos um array é basicametne igual ao superior, porém tipamos com chaves. exemplo  </p>
        <ul>
            <li>let listaFrutas: string[] = ['pera', 'maca', 'melancia']</li>
            <li>const sequenciaNumeros: number[] = [2, 4 , 5 , 6] </li>
        </ul>
        <h2> O type Any: </h2>
        <p> O type ANY é um processo que funciona apenas no TypeScript. Ele é desconsiderado quando geramos o arquivo JS. Ele é basicamente o último recurso, ou seja, quando nao dá mais para fazer de outra forma.</p>
        <p> Em um exemplo prático, quando temos um array de string e por algum motivo queremos dar um PUSH em um number nesse mesmo array, o que fazer? É ai que entra o type ANY.</p>
        <ul>
            <li> let lista : any = ['marcos', 'joao', 442] </li>
        </ul>
        <p> Em outras palavras, ela basicamente diz: Typescript, pode ignorar a tipagem dessa variável. </p>
        <h2>Types em Funções </h2>
        <p> Ao falarmos de funções precisamos abrir os olhos em seus parâmetros e também em seu retorno. </p>
        <p> Nos Parâmetros typamos normalmente dentro dos parâmetros.</p>
        <ul>
            <li> function allName(name: string, lastName: string){}</li>
        </ul>
        <p> Já para typar o retorno de uma função, colocamos entre o parametro e o corpo dela: </p>
        <ul>
            <li> function allName(name: string, lastName: string): string{}</li>
        </ul>
        <p> Dessa forma a função estará completamente typada. </p>
        <h2> Contexting Types </h2>
        <p> Muitas vezes o próprio TS apenas de olhar o que está acontecendo ele será capaz de deduzir o type quando ele for "óbvio". Em resumo, o typescript possui a sua inteligência. É importante entender o porque o typescript se comporta dessa forma.</p>
        <h2>Type em Objects</h2>
        <p> Aqui aprendemos um dos types mais utilizados dentro do universo da programação. Vamos começar falando de objetos sendo passados para dentro de funções. Quando passamos objetos por parâmetros para dentro de funções, podemos typar as propriedades desejadas dentro desse objeto. Exemplo: </p>
        <ul>
            <Li> function falaNome (usuario: {nome: string , idade:number})</Li>
        </ul>
        <p> Vale a pena ressaltar que podemos informar também que podemos enviar propriedades opcionais ( que podem ou não ser enviada) e para isso colocamos o <span>?</span>. Exemplo:</p>
        <ul>
            <li>function falaNome (usuario: {nome <span>?</span>: string , idade <span>?</span>:number})</li>
        </ul>
        <h2> Múltiplos Tipos </h2>
        <p> Em alguns casos em específico podemos nos deparar com a situação de uma variável poder vir a receber mais de um tipo de type.  Para isso utilizamos o operador <span>|</span>. Ex:</p>
        <ul>
            <li> const idade: string | number = 90</li>
        </ul>
        <p> Dessa forma estamos informando ao TypeScript que a idade pode vir a ser uma string ou pode vir a ser um number(Union Types).</p>
        <p> Caso tenhamos uma função que recebe uma variável idade como o exemplo acima, e dentro dessa função executemos algum método específico de um dos possíveis types, é necessário verificar o type antes com if/else. Exemplo: Se passamos uma variável typada como number | string, com o valor de string, para executarmos um toUpperCase por exemplo, será necessário verificarmos if( typeof string).... pois senão o typescript irá acusar erro pois não é possível usar toUpperCase em variáveis do tipo Number.</p>
        <h2> Criando Types </h2>
        <p> Geralmente quando criamos type próprios utilizamos o padrão chamado PascalCase, e para criarmos funciona basicamente igual uma variável, exemplo:  </p>
        <ul>
            <li> type NomeCompleto = string</li>
        </ul>
        <p> Dessa forma já podemos utilizar nosso type desta forma : </p>
        <ul>
            <Li> let nome: NomeCompleto = 'Guilherme' </Li>
        </ul>
        <p> Geralmente utilizamos types próprios em duas situações: Quando queremos simplificar e organizar melhor nosso código, geralmente quando estamos trabalhando com objetos e o segundo motivo é quando o type é replicável em outras partes do nosso código. Dentre elas , utilizamos mais quando falamos de objeto. </p>
        <p> Muitas vezes ao typarmos os parâmetros necessários de um objeto igual feito acima, fica extremamente cansativo e de forma não legível, pois no exemplo acima temos apenas dois parâmetros, porém e quando formos passar 10, 15 parâmetros ? </p>
        <p> Quando isso acontecer, podemos criar o type do próprio objeto facilitando a legibilidade e futuras manutenções. </p>
        <p> Para criar esses próprios types podemos utilizar tanto via type quanto via interfaces, porém a sintaxe é praticamente a mesma. A diferença é que com type nao podemos realizar alterações e no interface permite alterações. (<a href="https://alunos.b7web.com.br/curso/typescript/type-e-interface-como-usar-e-diferencas">Aula - $$$</a> ). Geralmente será utilizado o type.</p>
        <img src="../../img/tpscp/t1.jpg" alt="">
        <img src="../../img/tpscp/t2.jpg" alt="">
        <h2> Type Assertions </h2>
        <p> Em outras palavras é quando ajudamos o typescript a ser um pouco mais específico. Por exemplo, ao selecionarmos um input que é um objeto HTML (document.getElementByID('id')), ela irá retornar um objeto chamado HTMLElement que é um elemento geral do HTML( Div, botao, input, qualquer coisa). Porém quando tentamos acessar o value do input, ele irá dar um erro. E porque isso acontece? Acontece pois nem todos esses caras (HTMLElements) terão uma propriedade value. Uma div por exemplo não possui, já um input possui. Em geral, precisamos ajudar o type script a saber que este input que estamos pegando é de fato um input. </p>
        <ul>
            <Li>let idade = document.getElementById('ID') <span>  as HTMLInputElement</span></Li>
        </ul>
        <p> Todo elemento é um HTMLElement, porém dentro do HTMLElement possuimos alguns tipos diferentes com propriedades diferentes.  </p>
        <h2> Type Literais</h2>
        <p> Pode parecer complicado no início mas depois que compreende fica fácil. É básicamente quando nós dizemos o type do item específico e dizemos exatamente o valor que ele terá. Exemplo: </p>
        <ul>
            <li> let nome: 'guilherme' = 'guilherme'</li>
        </ul>
        <p> Dessa forma estamos definindo que a variável nome é typada como guilherme. Ela só irá aceitar o valor guilherme. Aparentemente parece inútil pois podemos criar uma constanet ao invés de let, e o próprio JS irá bloquear. Os types literais em definições de variáveis são basicamente inúteis, porém não é ali que utilizamos ele no dia a dia. Ali foi só um exemplo para entender o básico. Vamos ao dia a dia. </p>
        <p> No exemplo abaixo mostramos uma cenário que pode ser útil. Imagine que exista a função que receba dois parametros, o texto e o seu alinhamento. Se enviarmos right, left tudo bem, porém podemos enviar blablabla por exemplo e desta forma o texto não irá se alinhar. Nesse caso, usamos os literals types, para dizer exatamente os tipos que podemos vir a aceitar </p>
        <img src="../../img/tpscp/t3.jpg" alt="">
        <p> Nesse outro exemplo, podemos enviar ou as propriedades ou a palavra auto, então podemos fazer desse jeito: </p>
        <img src="../../img/tpscp/t4.jpg" alt="">
        <h2> Types para Funções: </h2>
        <p> Acima já vimos tudo sobre parametros e etc, porém aqui vai ser possível criar um type não só sobre os parametros, mas sim sobre todos os parâmetros e retornos que uma função deve ter. Veremos na prática. No exemplo veremos funções relacionadas a matemática. Ela receberá dois números e um retorno. Ex : Soma. Para isso, podemos criar um type para a função inteira, padronizando seus parâmetros e seu retorno de uma vez só. Exemplo:  </p>
        <img src="../../img/tpscp/t5.jpg" alt="">
        <h2> Retorno Void </h2>
        <p> É uma função que não possui retorno. Podemos ver isso geralmente quando iremos excluir algum elemento da tela, entre diversas e diversas outros exemplos. Agora quando falamos em Types, se criarmos UMA FUNÇÃO e colocar nela o retorno VOID, significa que obrigatóriamente ela não irá retornar nada. Agora, quando criamos um type para uma função, e dentro do type colocamos seu retorno como void, significa que não estamos esperando nenhum tipo de retorno naquela função. Logo, caso ela venha a retornar um string, ou qualquer outra coisa, o typescript não irá reclamar. </p>
        <h1> Configurando o TypeScript </h1>
        <h2> watchMode </h2>
        <p> A partir daqui vamos avançando nos conceitos estruturais do TS e começamos a nos aproximar no mundo real, da prática.  </p>
        <p> Toda vez que fazemos alguma alteração dentro do TS, para executar precisamos abrir o terminal e executar os comandos vistos no início dessa página, para ele gerar um arquivo e aí sim executar. Porém em projetos reais, temos dezenas e centenas de arquivos TS, logo não se torna viável realizar esse comando para cada um dos arquivos. Para isso vem o watchMode. utilizamos o mesmo comando com uma excessão, adicionamos outro carinha: <span>tsc src/scripts.ts -w</span>. A partir de aogra o projeto ficará em watchMode( monitoramento), logo a cada mudança, ele implementa a alteração.</p>
        <h2> tsConfig.Json </h2>
        <p> Até o momento estamos trabalhando só com um arquivo, porém como ja citamos, um projeto pode ter centenas de arquivos TS. Para isso precisamos começar a criar arquivos de configuração do projeto. Para isso começamos com o comando  <span>ts --init</span> e você reparará que será criado um ar quivo tsconfig.json. Dentro dele teremos uma série de configurações (a maioria comentada) que veremos em breve sua importância. Apartir de agora, apenas pelo fato dele estar instalado, podemos executar o comando <span>tsc</span> na qual ele "sozinho" irá converter todos os arquivos necessários para a conversão. Nesse processo, ele irá entrar em todas as páginas do projeto e irá gerar um arquivo, ele vasculha o projeto inteiro. </p>
        <p> A partir de agora, todos as configurações (erros, onde colocar, etc) serão trabalhados dentro do arquivo de configuração. </p>
        <h3> Colocando "configurações" </h3>
        <p> Lá embaixo, fora do objeto json, devemos colocar o exclude. Com ele, colocamos arquivos que não será compilado pelo typescript. Exemplo: </p>
        <p> Excluindo toda a pasta node_modules, excluindo o arquivo outro.ts , excluindo em todo o projeto qualquer arquivo que acabe com .dev.ts</p>
        <img src="../../img/tpscp/ts6.jpg" alt="">
        <img src="../../img/tpscp/ts7.jpg" alt="">
        <img src="../../img/tpscp/ts8.jpg" alt="">
        <p> Da mesma forma que trabalhamos com o exclude também podemos trabalhar com o Include. A partir do momento que colocamos o Include, ele só passará a compilar os arquivos selecionados dentro do que está incluso. </p>
        <h3> Entendendo o Target </h3>
        <p>Por padrão já vem sempre marcada com o ES5. Aqui ele seleciona a versão do JS que será compilado. Caso usemos dentro do ES5 uma feature do ES6, ele irá "transformar" os recursos novos para recursos que é aceitável dentro do ES5. </p>
        <h3> Libs no TypeScript </h3>
        <p> Aqui aprenderemos mais sobre a opção lib[], </p>



    </main>
</body>
</html>