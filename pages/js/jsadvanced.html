<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> JS Avançado </title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <h1> JavaScript Avançado</h1>
        <h2> Requisições </h2>
        <p> Aqui começaremos a usar tecnologias mais avançadas no JS. Aqui começaremos a utilizar o "grosso" do JS. Aqui começaremos a ver o mundo externo.</p>
        <p> Para começar a entender sobre requisições precisamos começar entendendo oque é síncrono e assíncrono. </p>
        <ul>
            <li>Síncrono - Basicamente na programação quando dizemos que alguma coisa é síncrona, basicamente estamos dizendo que uma coisa espera a outra para executar a próxima tarefa. Basicamente executa uma linha, termina, e parte para a debaixo, termina, e assim sucessivamente.</li>
            <li>Assíncrono - É quando as coisas funcionam fora de ordem. Por exemplo, se sua aplicação tiver que consultar um banco de dados e esperar ela retornar uma lista. Um processo assíncrono é quando a sua aplicação continua rodando enquanto ela recebe esses dados. Ela não precisa esperar travando a aplicação para que o usuário continue a utilizando. </li>
        </ul>
        <h2>Como a internet funciona ?</h2>
        <p> É importante aprender os conceitos iniciais, para depois ter melhor entendimento de como funciona a mão na massa. Toda vez que através de nossos dispositivos acessamos algum servidor externo, essa ação é chamada de Requisição. Ao acessarmos o goggle e procurarmos pela previsão do tempo por exemplo, estamos realizando uma requisição ao google.</p>
        <p> Bastante coisas no universo da programação web será baseada em Request e Response. Ao acessar o google, estamos fazendo uma requisição("google, me envie a página que eu quero"), e dentro dessa requisição, enviamos diversas informações ao google para ajudar os seus servidores a achar as informações que desejamos obter. Essas informações geralmente são enviadas através do Head e do Body da requisição. </p>
        <p> Após a requisição acontecer, o servidor nos envia a Resopnse. Que também possui seu Head e seu Body, que enviam dados diferentes do que na Request, mas a ideia funciona da mesma maneira. </p>
        <h2> Como uma API funciona ?</h2>
        <p> Além das requisições, também é de extrema importância que saibamos o que é uma API e o que ela faz. Api = Application Programming Interface. Uma API nada mais é do que uma forma para realizar a comunicação de um sistema e outro. Por exemplo, ao cadastrarmos um usuário no sistema, precisamos de uma API para conectar nosso programa, com o nosso banco de dados. Mesmo falando de máquinas, é necessário que usemos uma linguagem para a comunicação entre elas, e nesse caso, a linguagem mais utilizada no momento é o JSON-Javascript Object Notation. Para ver melhor sobre JSON e suas rotas, acesse <a href="https://jsonplaceholder.typicode.com/" target="_blank">JsonPlaceHolder</a></p>
        <h2> O que é um Callback </h2>
        <p> Este conceito não tem relação direta com requisições, porém também pode ser aplicado, mas será muito utilizado em eventos de click, eventos de teclado, etc. Mas enfim, o que é callback? CallBack a grosso modo é ligar de volta. Callback aplicado na programação, é quando criamos uma função, passamos para alguma parte do código para delegar a essa parte qual o momento que essa função será ativada. É uma função que criamos para ser executada no futuro. Já o CallBack aplicado em requisições funcionam da mesma forma. Ao realizarmos uma requisição ao servido, quando a resposta estiver pronta, ele fará alguma coisa com a resposta.(Esse faz alguma coisa com a resposta será o callback) </p>
        <h2> Requisição na prática: </h2>
        <p> Para começarmos utilizamos o fetch('url'), na qual o primeiro parâmetro colocamos a url desejada, e em seguida o .then(funcao(response)), que significa, quando voce receber ua resposta da requisição,  execute uma função específica com essa resposta. Como parâmetro nessa função, recebemos por parâmetro um response, que contem a resposta, na qual podemos colocar response.json(), que transformaremos a resposta para json. E então, colocamos outro .then((data)=>{}) </p>
        <p> Abaixo separado segue o passo a passo: </p>
        <ul>
            <li>fetch("http://urlqualquerdarequisição") -- aqui voce informa a URL da requisição</li>
            <li>.then((response)=> {return response.json()}) -- aqui voce esepra a resposta, e transforma p/ JSON</li>
            <li>.then((data ou json)=>{ // aqui voce tem o objeto em JS da resopsta, pronto para ser usado,armazenado,ou qualquer outra coisa que queira manusea-lo})</li>
        </ul>
        <p> Basicamente funciona em três tapas. Primeiro informamos a URL e fazemos a requisição, depois pegamos a resposta pura e transforfamos para objeto, e por fim temos o objeto puro JS pronto para ser utilizado.</p>
        <!-- PROMISSES-->
        <h2> Entendendo Promises</h2>
        <p> Conceito primordial para o bom fluxo de um Dev.Web. Ao pé da letra é uma promessa. Sempre usaremos Promises quando formos realizar tarefas que será demorada, que em algum momento ela será finalizada e quando ela for finalizada nós faremos algo com a resposta dela. Toda a função fetch nos retorna como resultado final uma Promise. Básicamente ele nos diz que a resposta da função fetch é que em algum momento do futuro iremos receber uma resposta,  seja rápido ou não. Sempre encima de promises podemos utilizar um .then, que é : Quando receber a resposta, faça isto. </p>
        <p> Baseado nisso, podemos montar a requisição acima de uma forma mais separada. </p>
        <ul>
            <li>const req = fetch('http://urlqualquerdarequisição')</li>
            <li> dai abaixo, de forma separada, podemos utilizar o .then na variavel req.</li>
            <li>req.then((response)=>{response.json()})</li>
            <li>req.then((json)=>// {fazer o que quiser com o objeto puro.})</li>
        </ul>
        <p> Além do .then() toda promise também nos da mais duas funções que podem ser executadas. .catch(()=>{}), nos permite tratar de erros, caso por algum motivo sua requisição não funcione, caso o servior esteja fora do ar, qualquer coisa do tipo, ele nos permite tratar esse erro e informar ou não ao usuário o que está acontecendo por exemplo. Junto do catch, vem por parametro o error, na qual podemos dentro dele capturar. ex: </p>
        <ul>
            <li>.catch((error)=>{//aqui podemos mexer ou não com esse error.})</li>
        </ul>
        <p> Depois de tudo podemos colocar o .finally(), que é basicamente o final de tudo. Na prática, utilizamos por exemplo, quando queremos bloquear o formulário até ele ser finalizado. </p>
        <h2> Estados de uma Requisição</h2>
        <p> Todas as requisições possuem seu status, que são informadas por números. Abaixo citaremos os principais.</p>
        <ul>
            <li>200- Resposta de Sucesso (OK)</li>
            <li>201- Resposta de Sucesso de Criação.</li>
            <li>301- A URL acessada foi alterada permanentemente</li>
            <li>400- Requisição está errada.</li>
            <li>401- Tentando acessar algo sem autorização</li>
            <li>404- Url não existe.</li>
            <li>405- Método não permitido para a determinada URL.</li>
            <li>500- Erro no Servidor, o navegador não sabe o que aconteceu.</li>
        </ul>
        <p> Dentro de uma requisição, quando recebemos a response dentro do primeiro callback, conseugimos pegar esse status (response.status), e analisar o que está acontecendo com aquela resposta do servidor.</p>
        <h2> Métodos de Envio de uma requisição.</h2>
        <p> Geralmente ao enviarmos dados para o servidor utilizamos o método GET. Tanto que por padrão, quando não informamos nenenhum método, ele utiliza o GET. Porém ele não é o único, também temos o POST, PUT, DELETE, entre outros, porém de início já basta esse. </p>
        <ul>
            <li>GET- Pegar informações do servidor</li>
            <li>POST- Mandando informações para o servidor.</li>
            <li>PUT- Quando queremos alterar alguma informação.</li>
            <li>DELETE- Método para remover alguma informação.</li>
        </ul>
        <p>Quando utilizamos o fetch, por padrão (GET), nós utilizamos apenas um parametro que é a URL. Quando queremos utilizar outros métodos, enviamos como segundo parâmetro um objeto, com três coisas dentro, method, headers, body.</p>
        <ul>
            <li>{ method: 'POST',</li>
                <ul>
                    <li>Aqui informamos o método sem ser o GET</li>
                </ul>
            <li>headers: {'Content-Type':'application/json'},</li>
                <ul>
                    <li>Aqui informamos ao servidor em qual formato enviaremos o body, que no caso é via JSON. </li>
                </ul>
            <li>body: JSON.stringify(objParaAdicionar)}</li>
                <ul>
                    <li>Aqui enviamos o corpo da requisição em si. Pegamos um objeto e traduzimos ele para JSON para que posas ser enviado.</li>
                </ul>
        </ul>
        <h2> Async  & Await</h2>
        <p>Aqui iremos aprender a fazer a mesma requisição, porém de forma talvez mais simples, com algumas diferenças e benefícios. O Fetch trabalha de forma assíncrona, ele retorna uma promise que precisa de seus callbacks. O que vier depois do fetch, ele será executado. Porém existe uma forma de você forçar o código a ficar síncorno, ou seja, esperar o código para depois continuar. </p>
        <p> Para isso, precisamos colocar  antes de uma função, a palavra async. Exemplo:</p>
        <ul>
            <li>async funciton clicou(){}</li>
            <li>const clicou = async function(){}</li>
            <li>const clicou = async ()=>{}</li>
        </ul>
        <p> Em seguida, precisamos armazenar a requisição em uma variável e colocar a palavra await.</p>
        <ul>
            <li>const req = await fetch('http://urlqualquerdarequisição')</li>
                <ul>
                    <li>Esse await basicamente faz freiar o código, fazendo com que ele espere a req.</li>
                </ul>
        </ul>
        <p> Deopis precisamos transforma-la em JSON.</p>
        <ul>
            <li>const json = await req.json();</li>
                <ul>
                    <li>Aqui estamos pegando a resposta da requisição acima, jogando a função JSON para transforma-la em objeto e armazenando-a em uma variável</li>
                </ul>
        </ul>
        <p> Agora abaixo basta  utilizar o objeto na variavel json, e utiliza-la da forma que melhor entender. Essa forma acima é mais utilizada pois torna o código mais limpo. Ela pode ser utilizada em qualquer método. </p>



        <h2> EJ6 </h2>
        <p> Aqui vem a parte "novidades de funcionalidades" (que não são mais tão novidadesa assim) que foram implementadas no JS junto com o ES6., na qual são de extrema importância no dia a dia. Algumas ja vimos anteriormente, mas vale ressaltar aqui.</p>
        <h3> Function vs Arrow Functions</h3>
        <p> A maior diferença entre functions e arrow functions é o contexto do objeto This. O valor do objeto this pode variar de acordo com o contexto que criamos a função. Funções criadas com o nome Function tem o seu próprio this, já as funções com arrow, tem o this de acordo com o escopo que foram criadas.  </p>
        <p> Arrow functions nao possuem this próprio. Dentro de uma Arrow, o this estará apontando para o contexto/escopo em qual a função foi criada. Em resumo a ArrowFunction usa o this do contexto em que foi criada, e a Function cria o seu próprio contexto this. </p>
        <h3>Parâmetros Dinâmicos</h3>
        <p>Muitas vezes iremos nos deparar cons ituações que iremos precisar enviar parâmetros mas sem saber a quantidade em específico. para isso, podemos utilizar dois métodos.</p>
        <ul>
            <li>arguments - dentro da função podemos utilizar a variavel especial do JS arguments, que retorna um objeto com todos os parâmetros passados. O arguments em arrow functions funciona igual o this, ele irá herdar de onde ela foi criada.</li>
            <li>Spread Operator - dentro do paraenteses de parametro da função, podemos colocar (...params), de forma que vai em forma de array todos os parametros passados. Tirando isso, podemos por exemplo (parametro1, ...params), dessa forma o primeiro parametro irá para a variável parametro1, e todo o resto para ...parms em forma de array.</li>
        </ul>
        <h3> Params Default</h3>
        <p> Função mais moderna no JS que nos permite atribuir valor de um parâmetro dentro da função. por exemplo.</p>
        <ul>
            <li>function sayMyName(name = 'padrao'){}</li>
                <ul>
                    <li>Aqui criamos uma função, que ao chamarmos, se passarmos algum valor por parametro ele irá atribuir este valor, e caso não passemos nada por parâmetro ele irá setar o valor default definido, que no caso é o 'padrao'. </li>
                </ul>
        </ul>
        <h3> Desestruturação</h3>
        <p> É uma forma que o JS nos proporciona de extraírmos apenas aquilo que desejamos de um objeto. Por exemplo, supomos que tenhamos um objeto user, e nele possuimos primeiroNome, ultimoNome, idade, instatgram, skills, e que desse objeto, gostariamos de pegar apenas o primeiroNome e o ultimoNome. De maneira convencional, poderiamos fazer:  </p>
        <ul>
            <li>const lastName = user.lastName</li>
            <li>const firstName = user.firstName</li>
        </ul>
        <p> Porém com as modernidades do JS, podemos fazer isso de forma mais prática, e aí que entra a Desestruturação. Para isso, criamos uma const e abrimos chaves, e recebe user. Porém vale ressaltar que o nome da propriedade que queremos pegar tem que ser exatamente igual a informada no objeto.</p>
        <ul>
            <li>const {firstName, lastName} = user</li>
                <ul>
                    <li>Por via das dúvidas, caso queiramos desestruturar um objeto, já alterando o nome de sua variável para o escopo desejado, basta colocarmos: </li>
                        <ul>
                            <li>const {firstName: primeiroNome} = user</li></li>
                        </ul>
                </ul>
        </ul>
        <p> Desas forma podemos utilizar essas variaveis de forma normal igual a citada no exemplo anterior. Vale lembrar que a desestruturação também pode ser utilizada em arrays. Dentro de objetos, delimitamos seu começo e fim através de chaves e dentro de array delimitados através de colchetes. Ou seja, para desestruturar um array, ao invés de chaves colocamos colchetes. </p>
        <p> Outra diferença é que para pegarmos os valores desejados, em objetos pegamos pelo nome do atributom, e em arrays iremos pegar pela posição desejada. Supomos que tenhamos um array como uma lista de compras com pera, maca, uva, melancia. Para desestruturar: </p>
        <ul>
            <li>const [item1, item2, item3] = array </li>
                <ul>
                    <li> Dessa forma, criamos uma variavel item1, que receberá o valor de pera, e assim sucessivamente.</li>
                </ul>
        </ul>
        <h3> Rest Operator</h3>
        <p> Através do RestOperator, podemos pegar todo o restante de um objeto e atribuirmos em uma variável. Funciona básicamente igual vimos anteriormente em funções. A única regra do Rest operator é que ele sempre precisa estar em última posição. </p>
        <ul>
            <li>const {firstname, secondName, ...rest} = user </li>
                <ul>
                    <li> Dessa forma, atribuimos o primeiro e segundo nome em suas variáveis, e todo o restante do objeto na variavel rest.</li>
                </ul>
        </ul>
        <h3> Spread Operator & Imutabilidade</h3>
        <p> Spread - espalhar. A sintaxe do Spread é a mesma do Rest porém, funciona de forma diferente. Quando avançarmos nossos estudos e entrarmos em ReactJS etc, iremos ver um princípio muito forte chamado de Imutabilidade. Basicamente quando queremos fazer alterações em um objeto por exemplo, nós nunca mudamos o dado bruto, nós criamos um novo objeto, clonando suas informações e assim realizando as alterações. Porém para clonarmos o objeto na mão irá gerar um trabalho considerável. Para isso que existe o SpreadOperator.  Ao invés de passarmos propriedade por propriedade, fazemos assim: </p>
        <ul>
            <li>const newUser = {...user}</li>
                <ul>
                    <li>Dessa forma o newUser, recebe tudo que está dentro de user.(clone).</li>
                </ul>
        </ul>
        <p> No JS quando temos duas propriedades com o mesmo nome dentro de um objeto, a última propriedade é a que irá prevalecer. Dessa forma, ao criarmos algum objeto, podemos sobrescrever algum atributo em específico. Ex:  </p>
        <ul>
            <li>const updateUser = {...user, instagram:'instagramDoNewUser'}</li>
                <ul>
                    <li>Assim ele irá clonar o objeto, sobreescrevendo o instagram para o novo desejado.</li>
                </ul>
        </ul>
        <p> Assim como na desestruturação o SpreadOperator também funciona para Arrays.</p>

        <h3>EsModules</h3>
        <h3>Métodos em Arrays </h3>
        <p> Talvez uma das coisas que um DEV WEB mais irá fazer em seu dia a dia é manipular dados dentro de um array. Para isso, o JS já nos fornece alguns Helpers para nos ajudar.</p>
        <h4>Includes()</h4>
        <p> Verifica se alguma string ou array existe alguma coisa que estamos passando para dentro dela. Exemplo : Se na string 'Node.js' dermos um .includes('s') ele irá retornar true, pois contém. se dermos um .includes('f') ele irá retornar false. Vale ressaltar que assim como tudo no JS, ele é caseSensitive.</p>
        <h4>startsWith()/endsWith()</h4>
        <p> Segue o mesmo esquema do includes, é uma função que verifica se alguma string começa ou termina com o desejado. 
        <h4>find()</h4>
        <p> Assim como a tradução, serve para pesquisar alguma coisa dentro do array. Ele basicamente recebe uma função, na qual irá iterar todo o array e dentro dela executar algo. por exemplo:</p>
            <ul>
                <li>const arrayProcurado = array.find((produto)=>{//aqui faz o que quer})</li>
            </ul>
        <p>A ideia do Find é que ele espera que retornemos um booleano de dentro da função, ou seja, se colocarmos uma condição, ele irá retornar true or false caso essa condição seja ou não atendida. Caso a condição de margem para retornar-mos mais de um elemento, o primeiro elemento que ele achar que bata com a condição, será o retornado. Ex </p>
        <ul>
            <li>const arrayProcurado = array.find((produto)=> produto.preco>1000)</li>
                <ul>
                    <li>irá retornar o primeiro produto que o preço seja maior que 1000.</li>
                </ul>
        </ul>
     <h4>findIndex()</h4>   
     <p> Funciona exatamente igual o find(). Porém o find ao encontrarmos o objeto, nos retorna exatamente o objeto. Já o findIndex() nos retorna exatamente o seu índice.</p>    
     <h4>some()</h4>    
     <p> Verifica se algum elemento do nosso array bate com a condição dita. Também recebe uma função que irá iterar todo o array, e também retorna um boolean.</p>
     <ul>
        <li>const arrayProcurado = array.map((produto)=> produto.preco>1000)</li>
            <ul>
                <li>irá retornar true caso algum produto do array tenha o preço maior que 1000</li>
            </ul>
    </ul> 
    <h4>every()</h4>
    <p> Funciona exatamente igual o some, porém como o próprio nome já diz, ele irá retornar true apenas se todos os itens do array baterem com a condição.</p>
    <h4>map()</h4>
    <p>Dentro dos métodos talvez um dos mais utilizados no dia a dia. O map, serve basicamente para pegarmos o array de um jeito, e criarmos um novo array baseado no anterior porém com alguma propriedade modificada ou alguma alteração. O retorno do MAP, sempre vai ser um array com o mesmo número de posições que o array de base. (SEMPRE). Se não criarmos condição nenhuma, ele retorna um array com o mesmo número do arary base, todo undefined. Dessa forma podemos criar novos atributos para arrays de objetos, etc.</p>
    <h4>filter()</h4>
    <p>O filter diferente do array, retorna um array com posição diferente do original. Por exemplo. Temos um array com mil objetos. Com o filter, podemos criar um novo array que só faça parte os objetos cujo preço seja maior que mil.</p>
        <ul>
            <li>const arrayFiltrado = array.filter((product)=>product.price > 1000)</li>
                <ul>
                    <li>Aqui ele irá criar um novo array apenas com os objetos com preço selecionado</li>
                </ul>
        </ul>\
    <h4>reduce()</h4> 
    <p>No reduce funciona diferente de todos os outors. O reduce recebe dois argumentos. A ideia do reduce é pegar nosso array, e transformar em outro array com outros tipos de dados. </p>   

    </main>
</body>
</html> 