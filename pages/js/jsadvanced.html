<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> JS Avançado </title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <h1> JavaScript Avançado</h1>
        <h2> Requisições </h2>
        <p> Aqui começaremos a usar tecnologias mais avançadas no JS. Aqui começaremos a utilizar o "grosso" do JS. Aqui começaremos a ver o mundo externo.</p>
        <p> Para começar a entender sobre requisições precisamos começar entendendo oque é síncrono e assíncrono. </p>
        <ul>
            <li>Síncrono - Basicamente na programação quando dizemos que alguma coisa é síncrona, basicamente estamos dizendo que uma coisa espera a outra para executar a próxima tarefa. Basicamente executa uma linha, termina, e parte para a debaixo, termina, e assim sucessivamente.</li>
            <li>Assíncrono - É quando as coisas funcionam fora de ordem. Por exemplo, se sua aplicação tiver que consultar um banco de dados e esperar ela retornar uma lista. Um processo assíncrono é quando a sua aplicação continua rodando enquanto ela recebe esses dados. Ela não precisa esperar travando a aplicação para que o usuário continue a utilizando. </li>
        </ul>
        <h2>Como a internet funciona ?</h2>
        <p> É importante aprender os conceitos iniciais, para depois ter melhor entendimento de como funciona a mão na massa. Toda vez que através de nossos dispositivos acessamos algum servidor externo, essa ação é chamada de Requisição. Ao acessarmos o goggle e procurarmos pela previsão do tempo por exemplo, estamos realizando uma requisição ao google.</p>
        <p> Bastante coisas no universo da programação web será baseada em Request e Response. Ao acessar o google, estamos fazendo uma requisição("google, me envie a página que eu quero"), e dentro dessa requisição, enviamos diversas informações ao google para ajudar os seus servidores a achar as informações que desejamos obter. Essas informações geralmente são enviadas através do Head e do Body da requisição. </p>
        <p> Após a requisição acontecer, o servidor nos envia a Resopnse. Que também possui seu Head e seu Body, que enviam dados diferentes do que na Request, mas a ideia funciona da mesma maneira. </p>
        <h2> Como uma API funciona ?</h2>
        <p> Além das requisições, também é de extrema importância que saibamos o que é uma API e o que ela faz. Api = Application Programming Interface. Uma API nada mais é do que uma forma para realizar a comunicação de um sistema e outro. Por exemplo, ao cadastrarmos um usuário no sistema, precisamos de uma API para conectar nosso programa, com o nosso banco de dados. Mesmo falando de máquinas, é necessário que usemos uma linguagem para a comunicação entre elas, e nesse caso, a linguagem mais utilizada no momento é o JSON-Javascript Object Notation. Para ver melhor sobre JSON e suas rotas, acesse <a href="https://jsonplaceholder.typicode.com/" target="_blank">JsonPlaceHolder</a></p>
        <h2> O que é um Callback </h2>
        <p> Este conceito não tem relação direta com requisições, porém também pode ser aplicado, mas será muito utilizado em eventos de click, eventos de teclado, etc. Mas enfim, o que é callback? CallBack a grosso modo é ligar de volta. Callback aplicado na programação, é quando criamos uma função, passamos para alguma parte do código para delegar a essa parte qual o momento que essa função será ativada. É uma função que criamos para ser executada no futuro. Já o CallBack aplicado em requisições funcionam da mesma forma. Ao realizarmos uma requisição ao servido, quando a resposta estiver pronta, ele fará alguma coisa com a resposta.(Esse faz alguma coisa com a resposta será o callback) </p>
        <h2> Requisição na prática: </h2>
        <p> Para começarmos utilizamos o fetch('url'), na qual o primeiro parâmetro colocamos a url desejada, e em seguida o .then(funcao(response)), que significa, quando voce receber ua resposta da requisição,  execute uma função específica com essa resposta. Como parâmetro nessa função, recebemos por parâmetro um response, que contem a resposta, na qual podemos colocar response.json(), que transformaremos a resposta para json. E então, colocamos outro .then((data)=>{}) </p>
        <p> Abaixo separado segue o passo a passo: </p>
        <ul>
            <li>fetch("http://urlqualquerdarequisição") -- aqui voce informa a URL da requisição</li>
            <li>.then((response)=> {return response.json()}) -- aqui voce esepra a resposta, e transforma p/ JSON</li>
            <li>.then((data ou json)=>{ // aqui voce tem o objeto em JS da resopsta, pronto para ser usado,armazenado,ou qualquer outra coisa que queira manusea-lo})</li>
        </ul>
        <p> Basicamente funciona em três tapas. Primeiro informamos a URL e fazemos a requisição, depois pegamos a resposta pura e transforfamos para objeto, e por fim temos o objeto puro JS pronto para ser utilizado.</p>
        <h2> Entendendo Promises</h2>
        <p> Conceito primordial para o bom fluxo de um Dev.Web. Ao pé da letra é uma promessa. Toda a função fetch nos retorna como resultado final uma Promise. Básicamente ele nos diz que a resposta da função fetch é que em algum momento do futuro iremos receber uma resposta,  seja rápido ou não. Sempre encima de promises podemos utilizar um .then, que é : Quando receber a resposta, faça isto. </p>
        <p> Baseado nisso, podemos montar a requisição acima de uma forma mais separada. </p>
        <ul>
            <li>const req = fetch('http://urlqualquerdarequisição')</li>
            <li> dai abaixo, de forma separada, podemos utilizar o .then na variavel req.</li>
            <li>req.then((response)=>{response.json()})</li>
            <li>req.then((json)=>// {fazer o que quiser com o objeto puro.})</li>
        </ul>
        <p> Além do .then() toda promise também nos da mais duas funções que podem ser executadas. .catch(()=>{}), nos permite tratar de erros, caso por algum motivo sua requisição não funcione, caso o servior esteja fora do ar, qualquer coisa do tipo, ele nos permite tratar esse erro e informar ou não ao usuário o que está acontecendo por exemplo. Junto do catch, vem por parametro o error, na qual podemos dentro dele capturar. ex: </p>
        <ul>
            <li>.catch((error)=>{//aqui podemos mexer ou não com esse error.})</li>
        </ul>
        <p> Depois de tudo podemos colocar o .finally(), que é basicamente o final de tudo. Na prática, utilizamos por exemplo, quando queremos bloquear o formulário até ele ser finalizado. </p>
        <h2> Estados de uma Requisição</h2>
        <p> Todas as requisições possuem seu status, que são informadas por números. Abaixo citaremos os principais.</p>
        <ul>
            <li>200- Resposta de Sucesso (OK)</li>
            <li>201- Resposta de Sucesso de Criação.</li>
            <li>301- A URL acessada foi alterada permanentemente</li>
            <li>400- Requisição está errada.</li>
            <li>401- Tentando acessar algo sem autorização</li>
            <li>404- Url não existe.</li>
            <li>405- Método não permitido para a determinada URL.</li>
            <li>500- Erro no Servidor, o navegador não sabe o que aconteceu.</li>
        </ul>
        <p> Dentro de uma requisição, quando recebemos a response dentro do primeiro callback, conseugimos pegar esse status (response.status), e analisar o que está acontecendo com aquela resposta do servidor.</p>
        <h2> Métodos de Envio de uma requisição.</h2>
        <p> Geralmente ao enviarmos dados para o servidor utilizamos o método GET. Tanto que por padrão, quando não informamos nenenhum método, ele utiliza o GET. Porém ele não é o único, também temos o POST, PUT, DELETE, entre outros, porém de início já basta esse. </p>
        <ul>
            <li>GET- Pegar informações do servidor</li>
            <li>POST- Mandando informações para o servidor.</li>
            <li>PUT- Quando queremos alterar alguma informação.</li>
            <li>DELETE- Método para remover alguma informação.</li>
        </ul>
        <p>Quando utilizamos o fetch, por padrão (GET), nós utilizamos apenas um parametro que é a URL. Quando queremos utilizar outros métodos, enviamos como segundo parâmetro um objeto, com três coisas dentro, method, headers, body.</p>
        <ul>
            <li>{ method: 'POST',</li>
                <ul>
                    <li>Aqui informamos o método sem ser o GET</li>
                </ul>
            <li>headers: {'Content-Type':'application/json'},</li>
                <ul>
                    <li>Aqui informamos ao servidor em qual formato enviaremos o body, que no caso é via JSON. </li>
                </ul>
            <li>body: JSON.stringify(objParaAdicionar)}</li>
                <ul>
                    <li>Aqui enviamos o corpo da requisição em si. Pegamos um objeto e traduzimos ele para JSON para que posas ser enviado.</li>
                </ul>
        </ul>
        <h2> Promises com Async  & Await</h2>
        <p>Aqui iremos aprender a fazer a mesma requisição, porém de forma talvez mais simples, com algumas diferenças e benefícios. O Fetch trabalha de forma assíncrona, ele retorn auma promise que precisa de seus callbacks. O que vier depois do fetch, ele será executado. Porém existe uma forma de você forçar o código a ficar síncorno, ou seja, esperar o código para depois continuar. </p>
        <p> Para isso, precisamos colocar  antes de uma função, a palavra async. Exemplo:</p>
        <ul>
            <li>async funciton clicou(){}</li>
            <li>const clicou = async function(){}</li>
            <li>const clicou = async ()=>{}</li>
        </ul>
        <p> Em seguida, precisamos armazenar a requisição em uma variável e colocar a palavra await.</p>
        <ul>
            <li>const req = await fetch('http://urlqualquerdarequisição')</li>
                <ul>
                    <li>Esse await basicamente faz freiar o código, fazendo com que ele espere a req.</li>
                </ul>
        </ul>
        <p> Deopis precisamos transforma-la em JSON.</p>
        <ul>
            <li>const json = await req.json();</li>
                <ul>
                    <li>Aqui estamos pegando a resposta da requisição acima, jogando a função JSON para transforma-la em objeto e armazenando-a em uma variável</li>
                </ul>
        </ul>
        <p> Agora abaixo basta  utilizar o objeto na variavel json, e utiliza-la da forma que melhor entender. Essa forma acima é mais utilizada pois torna o código mais limpo. Ela pode ser utilizada em qualquer método. </p>
        <h2> EJ6 - Módules</h2>
        <p> Aqui vem a parte "novidades de funcionalidades" (que não são mais tão novidadesa assim) que foram implementadas no JS junto com o ES6., na qual são de extrema importância no dia a dia. Algumas ja vimos anteriormente, mas vale ressaltar aqui.</p>
        <h3> Function vs Arrow Functions</h3>
        <p> A maior diferença entre functions e arrow functions é o contexto do objeto This. O valor do objeto this pode variar de acordo com o contexto que criamos a função. Funções criadas com o nome Function tem o seu próprio this, já as funções com arrow, tem o this de acordo com o escopo que foram criadas.  </p>
        <p> Arrow functions nao possuem this próprio. Dentro de uma Arrow, o this estará apontando para o contexto/escopo em qual a função foi criada. Em resumo a ArrowFunction usa o this do contexto em que foi criada, e a Function cria o seu próprio contexto this. </p>
        <h3>Parâmetros Dinâmicos</h3>
        <p>Muitas vezes iremos nos deparar cons ituações que iremos precisar enviar parâmetros mas sem saber a quantidade em específico. para isso, podemos utilizar dois métodos.</p>
        <ul>
            <li>arguments - dentro da função podemos utilizar a variavel especial do JS arguments, que retorna um objeto com todos os parâmetros passados. O arguments em arrow functions funciona igual o this, ele irá herdar de onde ela foi criada.</li>
            <li>Spread Operator - dentro do paraenteses de parametro da função, podemos colocar (...params), de forma que vai em forma de array todos os parametros passados. Tirando isso, podemos por exemplo (parametro1, ...params), dessa forma o primeiro parametro irá para a variável parametro1, e todo o resto para ...parms em forma de array.</li>
        </ul>
        <h3> Params Default</h3>
        <p> Função mais moderna no JS que nos permite atribuir valor de um parâmetro dentro da função. por exemplo.</p>
        <ul>
            <li>function sayMyName(name = 'padrao'){}</li>
                <ul>
                    <li>Aqui criamos uma função, que ao chamarmos, se passarmos algum valor por parametro ele irá atribuir este valor, e caso não passemos nada por parâmetro ele irá setar o valor default definido, que no caso é o 'padrao'. </li>
                </ul>
        </ul>
        <h3> Desestruturação</h3>
        <p> É uma forma que o JS nos proporciona de extraírmos apenas aquilo que desejamos de um objeto. Por exemplo, supomos que tenhamos um objeto user, e nele possuimos primeiroNome, ultimoNome, idade, instatgram, skills, e que desse objeto, gostariamos de pegar apenas o primeiroNome e o ultimoNome. De maneira convencional, poderiamos fazer:  </p>
        <ul>
            <li>const lastName = user.lastName</li>
            <li>const firstName = user.firstName</li>
        </ul>
        <p> Porém com as modernidades do JS, podemos fazer isso de forma mais prática, e aí que entra a Desestruturação. Para isso, criamos uma const e abrimos chaves, e recebe user. Porém vale ressaltar que o nome da propriedade que queremos pegar tem que ser exatamente igual a informada no objeto.</p>
        <ul>
            <li>const {firstName, lastName} = user</li>
                <ul>
                    <li>Por via das dúvidas, caso queiramos desestruturar um objeto, já alterando o nome de sua variável para o escopo desejado, basta colocarmos: </li>
                        <ul>
                            <li>const {firstName: primeiroNome} = user</li></li>
                        </ul>
                </ul>
        </ul>
        <p> Desas forma podemos utilizar essas variaveis de forma normal igual a citada no exemplo anterior. Vale lembrar que a desestruturação também pode ser utilizada em arrays. Dentro de objetos, delimitamos seu começo e fim através de chaves e dentro de array delimitados através de colchetes. Ou seja, para desestruturar um array, ao invés de chaves colocamos colchetes. </p>
        <p> Outra diferença é que para pegarmos os valores desejados, em objetos pegamos pelo nome do atributom, e em arrays iremos pegar pela posição desejada. Supomos que tenhamos um array como uma lista de compras com pera, maca, uva, melancia. Para desestruturar: </p>
        <ul>
            <li>const [item1, item2, item3] = array </li>
                <ul>
                    <li> Dessa forma, criamos uma variavel item1, que receberá o valor de pera, e assim sucessivamente.</li>
                </ul>
        </ul>
        <h3> Rest Operator</h3>

    </main>
</body>
</html> 