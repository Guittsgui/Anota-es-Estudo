<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> JS Avançado </title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <h1> JavaScript Avançado</h1>
        <h2> Requisições </h2>
        <p> Aqui começaremos a usar tecnologias mais avançadas no JS. Aqui começaremos a utilizar o "grosso" do JS. Aqui começaremos a ver o mundo externo.</p>
        <p> Para começar a entender sobre requisições precisamos começar entendendo oque é síncrono e assíncrono. </p>
        <ul>
            <li>Síncrono - Basicamente na programação quando dizemos que alguma coisa é síncrona, basicamente estamos dizendo que uma coisa espera a outra para executar a próxima tarefa. Basicamente executa uma linha, termina, e parte para a debaixo, termina, e assim sucessivamente.</li>
            <li>Assíncrono - É quando as coisas funcionam fora de ordem. Por exemplo, se sua aplicação tiver que consultar um banco de dados e esperar ela retornar uma lista. Um processo assíncrono é quando a sua aplicação continua rodando enquanto ela recebe esses dados. Ela não precisa esperar travando a aplicação para que o usuário continue a utilizando. </li>
        </ul>
        <h2>Como a internet funciona ?</h2>
        <p> É importante aprender os conceitos iniciais, para depois ter melhor entendimento de como funciona a mão na massa. Toda vez que através de nossos dispositivos acessamos algum servidor externo, essa ação é chamada de Requisição. Ao acessarmos o goggle e procurarmos pela previsão do tempo por exemplo, estamos realizando uma requisição ao google.</p>
        <p> Bastante coisas no universo da programação web será baseada em Request e Response. Ao acessar o google, estamos fazendo uma requisição("google, me envie a página que eu quero"), e dentro dessa requisição, enviamos diversas informações ao google para ajudar os seus servidores a achar as informações que desejamos obter. Essas informações geralmente são enviadas através do Head e do Body da requisição. </p>
        <p> Após a requisição acontecer, o servidor nos envia a Resopnse. Que também possui seu Head e seu Body, que enviam dados diferentes do que na Request, mas a ideia funciona da mesma maneira. </p>
        <h2> Como uma API funciona ?</h2>
        <p> Além das requisições, também é de extrema importância que saibamos o que é uma API e o que ela faz. Api = Application Programming Interface. Uma API nada mais é do que uma forma para realizar a comunicação de um sistema e outro. Por exemplo, ao cadastrarmos um usuário no sistema, precisamos de uma API para conectar nosso programa, com o nosso banco de dados. Mesmo falando de máquinas, é necessário que usemos uma linguagem para a comunicação entre elas, e nesse caso, a linguagem mais utilizada no momento é o JSON-Javascript Object Notation. Para ver melhor sobre JSON e suas rotas, acesse <a href="https://jsonplaceholder.typicode.com/" target="_blank">JsonPlaceHolder</a></p>
        <h2> O que é um Callback </h2>
        <p> Este conceito não tem relação direta com requisições, porém também pode ser aplicado, mas será muito utilizado em eventos de click, eventos de teclado, etc. Mas enfim, o que é callback? CallBack a grosso modo é ligar de volta. Callback aplicado na programação, é quando criamos uma função, passamos para alguma parte do código para delegar a essa parte qual o momento que essa função será ativada. É uma função que criamos para ser executada no futuro. Já o CallBack aplicado em requisições funcionam da mesma forma. Ao realizarmos uma requisição ao servido, quando a resposta estiver pronta, ele fará alguma coisa com a resposta.(Esse faz alguma coisa com a resposta será o callback) </p>
        <h2> Requisição na prática: </h2>
        <p> Para começarmos utilizamos o fetch('url'), na qual o primeiro parâmetro colocamos a url desejada, e em seguida o .then(funcao(response)), que significa, quando voce receber ua resposta da requisição,  execute uma função específica com essa resposta. Como parâmetro nessa função, recebemos por parâmetro um response, que contem a resposta, na qual podemos colocar response.json(), que transformaremos a resposta para json. E então, colocamos outro .then((data)=>{}) </p>
        <p> Abaixo separado segue o passo a passo: </p>
        <ul>
            <li>fetch("http://urlqualquerdarequisição") -- aqui voce informa a URL da requisição</li>
            <li>.then((response)=> {return response.json()}) -- aqui voce esepra a resposta, e transforma p/ JSON</li>
            <li>.then((data ou json)=>{ // aqui voce tem o objeto em JS da resopsta, pronto para ser usado,armazenado,ou qualquer outra coisa que queira manusea-lo})</li>
        </ul>
        <p> Basicamente funciona em três tapas. Primeiro informamos a URL e fazemos a requisição, depois pegamos a resposta pura e transforfamos para objeto, e por fim temos o objeto puro JS pronto para ser utilizado.</p>
        <h2> Entendendo Promises</h2>
        <p> Conceito primordial para o bom fluxo de um Dev.Web. Ao pé da letra é uma promessa. Toda a função fetch nos retorna como resultado final uma Promise. Básicamente ele nos diz que a resposta da função fetch é que em algum momento do futuro iremos receber uma resposta,  seja rápido ou não. Sempre encima de promises podemos utilizar um .then, que é : Quando receber a resposta, faça isto. </p>
        <p> Baseado nisso, podemos montar a requisição acima de uma forma mais separada. </p>
        <ul>
            <li>const req = fetch('http://urlqualquerdarequisição')</li>
            <li> dai abaixo, de forma separada, podemos utilizar o .then na variavel req.</li>
            <li>req.then((response)=>{response.json()})</li>
            <li>req.then((json)=>// {fazer o que quiser com o objeto puro.})</li>
        </ul>
        <p> Além do .then() toda promise também nos da mais duas funções que podem ser executadas. .catch(()=>{}), nos permite tratar de erros, caso por algum motivo sua requisição não funcione, caso o servior esteja fora do ar, qualquer coisa do tipo, ele nos permite tratar esse erro e informar ou não ao usuário o que está acontecendo por exemplo. Junto do catch, vem por parametro o error, na qual podemos dentro dele capturar. ex: </p>
        <ul>
            <li>.catch((error)=>{//aqui podemos mexer ou não com esse error.})</li>
        </ul>
        <p> Depois de tudo podemos colocar o .finally(), que é basicamente o final de tudo. Na prática, utilizamos por exemplo, quando queremos bloquear o formulário até ele ser finalizado. </p>
        <h2> Estados de uma Requisição</h2>
        <p> Todas as requisições possuem seu status, que são informadas por números. Abaixo citaremos os principais.</p>
        <ul>
            <li>200- Resposta de Sucesso (OK)</li>
            <li>201- Resposta de Sucesso de Criação.</li>
            <li>301- A URL acessada foi alterada permanentemente</li>
            <li>400- Requisição está errada.</li>
            <li>401- Tentando acessar algo sem autorização</li>
            <li>404- Url não existe.</li>
            <li>405- Método não permitido para a determinada URL.</li>
            <li>500- Erro no Servidor, o navegador não sabe o que aconteceu.</li>
        </ul>
        <p> Dentro de uma requisição, quando recebemos a response dentro do primeiro callback, conseugimos pegar esse status (response.status), e analisar o que está acontecendo com aquela resposta do servidor.</p>
        <h2> Métodos de Envio de uma requisição.</h2>
        <p> Geralmente ao enviarmos dados para o servidor utilizamos o método GET. Tanto que por padrão, quando não informamos nenenhum método, ele utiliza o GET. Porém ele não é o único, também temos o POST, PUT, DELETE, entre outros, porém de início já basta esse. </p>
        <ul>
            <li>GET- Pegar informações do servidor</li>
            <li>POST- Mandando informações para o servidor.</li>
            <li>PUT- Quando queremos alterar alguma informação.</li>
            <li>DELETE- Método para remover alguma informação.</li>
        </ul>
        <p>Quando utilizamos o fetch, por padrão (GET), nós utilizamos apenas um parametro que é a URL. Quando queremos utilizar outros métodos, enviamos como segundo parâmetro um objeto, com três coisas dentro, method, headers, body.</p>
        <ul>
            <li>{ method: 'POST',</li>
                <ul>
                    <li>Aqui informamos o método sem ser o GET</li>
                </ul>
            <li>headers: {'Content-Type':'application/json'},</li>
                <ul>
                    <li>Aqui informamos ao servidor em qual formato enviaremos o body, que no caso é via JSON. </li>
                </ul>
            <li>body: JSON.stringify(objParaAdicionar)}</li>
                <ul>
                    <li>Aqui enviamos o corpo da requisição em si. Pegamos um objeto e traduzimos ele para JSON para que posas ser enviado.</li>
                </ul>
        </ul>
        <h2> Promises com Async  & Await</h2>
        <p>Aqui iremos aprender a fazer a mesma requisição, porém de forma talvez mais simples, com algumas diferenças e benefícios. O Fetch trabalha de forma assíncrona, ele retorn auma promise que precisa de seus callbacks. O que vier depois do fetch, ele será executado. Porém existe uma forma de você forçar o código a ficar síncorno, ou seja, esperar o código para depois continuar. </p>
        <p> Para isso, precisamos colocar  antes de uma função, a palavra async. Exemplo:</p>
        <ul>
            <li>async funciton clicou(){}</li>
            <li>const clicou = async function(){}</li>
            <li>const clicou = async ()=>{}</li>
        </ul>
        <p> Em seguida, precisamos armazenar a requisição em uma variável e colocar a palavra await.</p>
        <ul>
            <li>const req = await fetch('http://urlqualquerdarequisição')</li>
                <ul>
                    <li>Esse await basicamente faz freiar o código, fazendo com que ele espere a req.</li>
                </ul>
        </ul>
        <p> Deopis precisamos transforma-la em JSON.</p>
        <ul>
            <li>const json = await req.json();</li>
                <ul>
                    <li>Aqui estamos pegando a resposta da requisição acima, jogando a função JSON para transforma-la em objeto e armazenando-a em uma variável</li>
                </ul>
        </ul>
        <p> Agora abaixo basta  utilizar o objeto na variavel json, e utiliza-la da forma que melhor entender. Essa forma acima é mais utilizada pois torna o código mais limpo. Ela pode ser utilizada em qualquer método. </p>
        <h2> EJ6 - Módules</h2>
        <p> Aqui vem a parte "novidades de funcionalidades" (que não são mais tão novidadesa assim) que foram implementadas no JS junto com o ES6., na qual são de extrema importância no dia a dia.</p>
    </main>
</body>
</html>