<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> React JS</title>
    <link rel="stylesheet" href="../../styles/style.css">
</head>
<body>
    <main>
        <p><a href="../../index.html">Voltar</a></p>
        <nav class="navExpress">   
            <li> <a href="#states"> States & Events </a></li>
            <li> <a href="#estiliza"> Estilização</a></li>
            <li> <a href="#cv"> CiclosVida, Reqs, Hooks</a></li>
            <li> <a href="#rv6"> ReactRouter V6</a></li>
            <li> <a href="#capi"> Context API </a></li>
            <li><a href="#redux">Redux</a></li>
    </nav>
        <h1> React JS. </h1>
        <h2> O que é React JS ?</h2>
        <p> React é uma Biblioteca feita em JavaScript criada e mantida pelo Facebook. Vem com o objetivo de deixar as páginas mais "leves". Para começar a compreender, vamos relembrar do DOM. Dom é básicamente todos os elementos que estão na tela do browser. Cada item (botao,etc) é um elemento, e através do DOM conseguimos selecionar um elemento em específico e manipula-lo, adicionar evento, etc. Isso demanda processamento do computador do usuário que está acessando e dependendo do que você fizer, isso pode ser muito custoso.  </p>
        <p>Já no React isso não acontece, pois o react trabalha com o <span>Virtual Dom</span>. A grosso modo, é básicamente uma cópia do que você está vendo no computador só que direto na memória, uma cópia virtual. Você não ve mais ela existe. </p>
        <p> Dessa forma, quando usamos React, ao realizarmos alguma alteração na página, na verdade inicialmente ela é alterada apenas na cópia (VirtualDom) e depois ele compara a tela(DOM) com o resultado da modificação feita no (VirtualDom), e em seguida, ele faz a alteração apenas naquele item em que foi alterado. Dessa forma o processamento é reduzido drasticamente, pois só é processado no DOM (browser) aquilo em que foi modificado e não o DOM inteiro.</p>
        <p> Entendendo isso, que é a forma como o react trabalha, existe um conceito chamado <span> SPA </span> - Single Page Application, que é uma aplicação de uma página. Quando fazemos um projeto feito em react, nós temos apenas uma página e tudo é alterado dentro dessa mesma página. </p>
        <p> Para instalar o React é necessário que seja instalado o Node, caso não saiba, vá para o nosso <a href="../back-end/nodejs.html">Módulo de Node</a>.</p>
        <h2> Formas de criar projeto com React JS </h2>
        <p> Dentro do React existem várias formas de criarmos nossos projetos, aqui veremos as duas mais utilizadas no mercado. </p>
        <h3> Instalando via CRA - Create React App </h3>
        <p>Para começarmos, colocamos o comando: <span>npmx create-react-app nomedoprojeto </span> caso queiramos utilizar o React com JS. Já caso queiramos utilizar o React com TS, utilizamos o comando: <span>npmx create-react-app nomedoprojeto --template typescript</span>.</p>
        <p> Para rodar o projeto, abrimos o terminal do VSCODE, e rodar o comando: <span>npm start</span> dessa forma ele já irá abrir o navegador com nosso projeto rodando geralmente na porta 3000.</p>
        <h3> Instalando via Vite </h3>
        <p> Basicamente o vite é uma biblioteca que nos auxilia a criar projetos entre várias outras coisas. Ele geralmente cria o projeto de forma mais rápido do que o normal. Aqui utilizamos o comando <span> npm init vite nomedoprojeto -- --template react-js </span> em caso de usar o React com JavaScript. Já caso queira utilizar o React com Typescript, colocamos o comando: <span>npm init vite nomedoprojeto -- --template react-ts</span></p>
        <p> Em seguida, utilizamos o comando <span>npm install</span> para instalarmos todas as bibliotecas, e estará configurado/pronto para ser utilizado. Você irá reparar que ele será praticamente igual, seja criado por CRA ou VITE.</p>
        <p> Aqui para rodarmos o projeto colocamos o comando <span>npm run dev</span>.</p>
        <h2> Visão Geral de um Projeto Iniciado com React JS </h2>
        <p> Aqui iremos começar a entender tudo que vem dentro do projeto React criado. Para começar, vale saber que temos algumas diferenças sutís entre o projeto criado com CRA e com VITE (porém minúsculos detalhes). </p>
        <p> Dentro da CRA, teremos a pasta PUBLIC, onde irá conter o arquivo INDEX HTML. É dentro desse arquivo index, que possui apenas uma div que toda a sua aplicação será renderizada. Já no VITE é um pouco mais limpo, e está fora da pasta public. </p>
        <p> Em ambos os projetos terão uma pasta SRC, no qual dentro do CRA temos o APP.tsx e dentro do VITE temos o MAIN.TSX. Em sintaxe ambos os arquivos são exatamentes iguais. Em outras palavras, ali é onde está ordenando pegar o projeto inteiro e renderizar dentro da div principal. (Aqui eles pegam e jogam na tela). Agora, o projeto mesmo, está localizado dentro do arquivo <span>APP.TSX </span> (igual em ambos). Ali encontraremos o código da página em si. </p>
        <span> O código Fonte fica dentro da pasta SRC.</span>
        <h2> Componente </h2>
        <p> Geralmente a primeira coisa que fazemos quando estamos começando uma aplicação em React é ir no arquivo App.tsx e apagar tudo que está dentro dele. Todo o React é baseado em <span>Componentes</span>. Componentes são partes ou até mesmo um todo. Componente é basicamente uma função que geralmente retorna algo gráfico.</p>
        <img src="../../img/reactjs/r1.jpg" alt="">
        <img src="../../img/reactjs/r2.jpg" alt="">
        <p> Agora ao rodarmos o projeto teremos nosso primeiro Olá Mundo feito em ReactJS. Sempre que falarmos em criar um componente, provavelmente estaremos falando em criar uma função que retorna <span>geralmente</span> algo gráfico, podendo ser uma div, um botão, uma interface por completo. Tudo que iremos criar irá rodar dentro desse componente principal, inclusive podemos usar componentes dentro de componentes, passando dados ou não. </p>
        <h2> JSX </h2>
        <p> Antes de realmente mergulharmos no mundo do react, é importante entender sobre o famoso <span>JSX</span> e suas expressões. Ao criar o seu primeiro componente você irá perceber que foi utilizado HTML dentro de uma função JavaScript. Na verdade o que vimos não é HTMl(apesar de parecer bastante), e sim JSX. JSX é uma forma de digitar o código de forma mais simples, porém antes de ser exibido ele será convertido (pelo babel), e  recria utilizando o código sem ser com JSX. </p>
        <p> Basicamente na ilustração abaixo, mostra primeiro como que fica o código compilado pelo Babel e em seguida como que é mais simples digitar via JSX.</p>
        <p> Em resumo, é um pseudo HTML que é traduzido em código JavaScript que é traduzido pelo compilador que no caso é o Babel. Provavelmente iremos reparar maiores diferenças entre o html e o jsx quando formos utilizar css inline, classes, id's, etc.</p>
        <img src="../../img/reactjs/r3.jpg" alt="">
        <p> Agora que já entendemos o que é o JSX e que ele simplifica a escrita de JS para HTML, vamos começar a entender o porque ele se torna realmente útil para nossas aplicações. </p>
        <h3> Expressões no JSX</h3>
        <p> Uma outra das várias vantagens do JSX é que além de colocarmos código HTML dentro do universo JS, também podemos colocar JS dentro do HTML. Para jogar uma variável dentro do JSX basta colocarmos {}, e tudo que fica ali dentro vira JS, na qual podemos fazer qualquer coisa do universo JS. (contas,etc). Nesse exemplo abaixo, mostro um exemplo do uso de expressões: </p>
        <img src="../../img/reactjs/r4.jpg" alt="">
        <h2> Usando vários Componentes </h2>
        <p> Aqui é onde começamos a aprender realmente o fluxo do ReactJS, é a "vida real" dele. O ideal é que separemos cada componente em arquivos diferentes. Todo componente nós utilizamos ele como se fosse uma tag do HTML, abrimos e fechamos nele mesmo. Veja um Exemplo Abaixo:  </p>
        <img src="../../img/reactjs/r5.jpg" alt="">
        <p> <span> Mas quando criar um componente ?</span> Sempre que temos um bloco de código grande que precisemos de manutenção, criamos um componente. Sempre que uma parte for reutilizável devemos também criar um componente. </p>
        <p> Cada componente deve ficar em um arquivo separado, pois imagine um software real onde teremos 200 componentes e todos no mesmo arquivo. Ficaria praticamente impossível localizarmos e darmos manutenção. Então como boa prática, dentro da pasta <span>src</span> criamos uma pasta com o nome de components, e lá colocamos os mesmos (importando e exportando).</p>
        <h2> Props em Components </h2>
        <p> Aliado com Components, props também é a base para a criação de aplicações WEB. Imagine que o cabeçalho acima tenha um texto personalizavel por exemplo. Ficaria inviável ficar criando um componente para cada texto que deseja exibir no cabeçalho. Para isso existem as <span>props</span>. Props são os "atributos do HTML". No JSX temos os componentes e as props ( que no html seria a tag e o atributo). Para criarmos uma prop, colocamos por exemplo : </p>
        <img src="../../img/reactjs/r6.jpg" alt="">
        <p> Dessa forma você irá perceber que o typescript irá reclamar da palavra TITLE. Isso acontece, pois além de enviarmos as props para algum componente, é necessário que esse componente que irá receber esteja ciente/esperando receber as props. Para isso ele é recebido no parâmetro da função. Como estamos utilizando o TypeScript, é necessário typarmos essas props. Por padrão, criamos um type com o nome prop(como ele está dentro de um ecossistema separado, colocamos o nome de props mesmo). Exemplo abaixo de um componente recebendo props: </p>
        <img src="../../img/reactjs/r7.jpg" alt="">
        <p> Para utilizarmos essas props, podemos ou receber no parâmetro a props por inteiro e utilizar <span>{props.atributoPassado}</span>, ou podemos desestruturar somente o que iremos usar e receber {}. </p>
        <p> Assim como no TS normal, ao typarmos as props no componente que a receberá, podemos colocar <span>?</span> após o seu nome, para que ele passe a ser opcional. name<span>?</span>: string;. Caso não seja colocado esse operador <span>?</span> ele não irá aceitar a chamada do componente em questão sem a prop.</p>
        <h2> Children & Fragments </h2>
        <p> Outro conceito de extrema importância da base de React, é o conceito de Children e de Fragments. O conceito de <span>fragment</span> dentro do react é que nós só podemos retornar um único elemento. Não é possível retornar mais de um elemento. Por exemplo: Imagine que tenhamos uma div, e dentro dela um h1 e um p. É possível retornar esses 03 elementos, pois na verdade o que está sendo retornado é apenas uma div. Porém existirá casos no qual não caberá uma div, e você precise retornar apenas o h1 e o p (porexemplo). Nessa hora que entram os fragments. Fragments é uma forma de "envelopar" <span> < > conteúdo < /> </span>, para que consigamos retornar mais de um componente. Resumidamente o fragment serve para burlar a regra do retorno de um único componente. </p>
        <p> Mas e o Children ? Children é quando temos um componente que não abrimos e fechamos no mesmo item ou seja, abrimos e fechamos de forma separada.   </p>
        <p style="color: brown;"> FALTA REVER CHILDREN</p>

        <h1 id="states"> States & Events </h1>
        <h2> Criando Eventos </h2>
        <p> Já conhecemos o que são eventosdos nossos estudos de JS. (Caso não lembre volte ao módulo de <a href="../js/jsdom.html">Js-DOM</a>). No React utilizamos a sintaxe: <span>onClick={}</span>. Agora precisamos criar uma função, passar a denifição dela e por fim cria-la. </p>
        <p> Segue o exemplo: </p>
        <img src="../../img/reactjs/r8.jpg" alt="">
        <p> Também é possível criar uma função anonima c/ arrow function dentro dos <span>{}</span>.Evoluindo veremos vários tipos de evento, como evento de teclado, mudanças de algo, etc. Mas para avançar é de fundamental saber a base de como definir e como funciona sua estrutura. </p>
        <h2> Usando State </h2>
        <p>Aqui é onde começaremos a estudar os famosos <span>Hooks</span> do react. Hooks nada mais são do que funções do JavaScript, podendo ser executados por si só. Para entendermos o conceito de state precisamos saber que o React JS trabalha com o conceito de imutabilidade, ou seja, no React nós não alteramos nenhum dado em específico e sim trabalhamos com seu estado. Não adiantaira mudar uma variável diretamente pois assim que isso acontecesse o componente seria executado novamente e dessa forma ele voltaria pro seu valor original. </p>
        <p> Exemplo : Caso você tenha uma tag p, como valor 'Guilherme', e alteremos ele para João via função por exemplo, o nome seria alterado em memória, o componente inteiro seria renderizado novamente, e em seguida voltaria a assumir o seu valor inicial. </p>
        <p> Enfim entramos no <span>useState</span> que serve para gerenciar o estado de algum valor onde poderemos alterar e consultar também. Vamos a prática: </p>
        <img src="../../img/reactjs/r9.jpg" alt="">
        <p> Aqui atribuimos o useState com o valor inicial de Matheus, para a variável name. Porém ao darmos um console log nessa variável, iremos perceber que o useState retorna um array com duas posições. O primeiro valor é o seu valor inicial setado na função acima, e a segunda posição é uma função, que servirá para alterar a variável inicial em questão(nesse caso o name), que por padrão nomeamos com setName, ou setIdade, enfim, set o nome da variavel em questão. </p>
        <p> Agora que já entendemos a estrutura do useState <span>(variavelAtual, funçãoParaAlterarEstado => useState('ValorInicial))</span>, é necessáriio saber que o usestate sempre será visto de forma desestruturada. Exemplo:</p>
        <p style="text-align: center;"> <span style="color: green;">const [name, setName] = useState('Guilherme')</span></p>
        <p> Dessa forma, sempre que em tela precisemos alterar o valor de name, utilizamos o setName. </p>
        <p> Podemos ter um botão com um evento onClick que ativa uma função mudarNome, por exemplo, dentro dessa função usamos o setName('GuiGui'), que ela será alterada.</p>
        <p> Sempre que utilizamos essa função (vinda no segundo parametro do useState), temos como receber um prevState por parâmetro. Esse prevState apenas nos informa o valor do estado atual. Como boa prática, ao invés de mudarmos direto, podemos ativar uma function para se blindar de possíveis erros.</p>
        <p style="text-align: center;"> <span style="color: green;">setNumber((prevState)=> prevstate + 1)</span></p>
        <p> Dessa forma podemos nos "blindar" de double clicks, entre outros possíveis mini-bugs que o react pode vir a oferecer.</p>
        <p> Aqui abaixo temos um exemplo do uso de useState dentro de um input, onde pegamos o nome digitado e replicamos embaixo.</p>
        <img src="../../img/reactjs/r10.jpg" alt="">
        <h2> Comunicação entre Componentes </h2>
        <p> Quando a comunicação entre componentes se dá de pai para filho, uma das formas que temos de comunicar é pelas props, vistas nos tópicos acima. Mas e quando precisamos passar de filho para pai ? Vai ser normal em nossa caminhada nos depararmos com cenários na qual iremos precisar ao clicar em algo dentro de um componente, ativar alguma função que esteja do lado de fora dele(em algum outro componente).</p>
        <p> Por exemplo, dentro do componente app, temos o comopnente botao. Assim que clicarmos no botão, queremos ativar uma função que está dentro do componente App, como resolver? Para solucionar, nós declaramos a função a ser executada normalmente dentro do componente App, e em seguida passamos essa função via PROPS para o componente botão. Não precisa ser o mesmo nome da função declarada. Resumo: No componente App voce cria a função <span> botaoEventAction</span> e la nas props, voce pode passar como <span>clickFn</span>={botaoEventAction} por exemplo. Dessa forma, o componente botao irá receber essa props, e lá ativar o evento onClick={clickFn} . </p>
        <p> Exemplo em código abaixo: </p>
        <p> Componente app enviando a função via prop:</p>
        <img src="../../img/reactjs/r11.jpg" alt="">
        <p> Componente Botao recebendo a função via prop:</p>
        <img src="../../img/reactjs/r12.jpg" alt="">
        <p> Outra coisa que temos que nos atentar, é que é possível enviarmos uma frase por exemplo do filho para o pai via parâmetros. </p>
        <h2> Renderizando Listas </h2>
        <p> Constantemente dentro de nossas aplicações iremos nos deparar com a necessidade de renderizar listas por diversos motivos. Então mãos a obra. Supomos que tenhamos uma lista de mercado <span> let lista = ['maca','pera']</span>. Para renderizarmos essa lista no react, iremos necessitar da ajuda do JSX + expressões. No JS cru, temos a função map, que percorre todo um array. Aqui usaremos ela combinado junto com nosso JSX.</p>
        <img src="../../img/reactjs/r13.jpg" alt="">
        <p> Dessa simples forma nossa lista estará impressa na nossa aplicação. Porém, dentro do ReactJs, todo filho dentro de uma lista (li), cada child dessa lista precisa ter uma prop chamda key, na qual deve ser única. Dessa forma cada elemento da lista poderá ser reconhecido de forma individual. Mas de onde arrumar um número/chave individual ?  </p>
        <p> Dentro do método map, nós podemos receber dois parâmetros. o primeiro é o item a ser iterado pelo array, e o segundo é um item chamado index. Ele é básicamente um número que corresponde a posição do item dentro do array. Nesse caso, podemos aproveitar esse index para ele mesmo ser a nosas key do array. </p>
        <p> Exemplo abaixo: </p>
        <img src="../../img/reactjs/r14.jpg" alt="">
        <p> Da mesma forma que na lista acima nós repetimos uma li direta, é possível criarmos um componente , que retorne essa lista, e ao invés de colocarmos o li para repetir, colocar o componente em questão. Porém o x da questão é que ao enviarmos um componente para ser repetido no lugar da li (que é o que voce verá no dia a dia), voltará com o erro da key.</p>
        <p> Para solucionar isso, pasasmos o index junto com o componente e suas props. Sempre que renderizarmos qualquer coisa dentro de uma lista, é obrigatório no mesmo lugar que está o map enviar a prop <span>key.</span></p>
        <p> Exemplo:</p>
        <img src="../../img/reactjs/r15.jpg" alt="">
        <h2> Renderizando Conteúdo Adicional</h2>
        <p> Outra situação que iremos nos deparar constantemente é quando você quer renderizar algo mediante a alguma condição. "Se isso acontecer renderize isso, senão renderize aquilo", ou então "Se isso acotnecer renderize isso, senão não renderize nada". </p>
        <p> Muito se usa isso para fazer o loading por exemplo "Se a página estiver carregando, mostra, senão, não mostra". A forma mais fácil de fazer isso é da seguinte forma: Podemos criar um state de show com setShow, iniciando como false.  </p>
        <p> Em seguida usamos uma expressão onde nela mesmo já damos o retorno através do &&. Abaixo temos dois exemplos de renderização condicional (div e do textButton).</p>
        <img src="../../img/reactjs/r16.jpg" alt="">
        <h1 id="estiliza"> Estilizações</h1>
        <h2> Css no React </h2>
        <p> O básico do React já vimos, porém agora, e o CSS dele ? Não há limitações de efeitos quando falamos de css. Não existe algo do tipo "Não dá para fazer aquele efeito pois estamos no react". A partir daqui vamos ver todas as formas de estilização, quais as mais recomendadas, pré processadores etc. </p>
        <h3> Estilização Inline </h3>
        <p> Funciona de forma parecida com o CSS normal, porém de forma diferente. Aqui no react, a estilização é feita a base de <span>objetos</span>, porém é muito similar ao próprio CSS. Uma das diferenças é que nomes com mais de duas palavras, exemplo : <span>background-color</span> se tornaria <span>backgroundColor</span>. Aqui abaixo temos um exemplo de um botão sendo estilizado inline</p>
        <img src="../../img/reactjs/r17.jpg" alt="">
        <p> Porém quando você começar a estilizar inline, você irá perceber que o código vai ficando completamente ilegível, pois cada linha irá ficando com proporções gigantes. Dito isto, temos outras formas para a estilizações ficar mais legíveis. Devemos usar a inline apenas quando for algo extremamente pontual, ou quando recebermos propriedades dinâmicas. </p>
        <p> Estilizacões inline dinâmica é quando basicamente utilizamos propriedades externas dentro do inline. Por exemplo, ao clicarmos no botão queremos que ele fique azul. Para isso podemos criar um state boolean que começa como false. Ao clicarmos no botão ele flipara para true. Através disso podemos criar uma propriedade dinâmica Inline. Exemplo: if {clicked}, botao vermelho, else botao azul.</p>
        <p> Exemplo abaixo: </p>
        <img src="../../img/reactjs/r18.jpg" alt="">
        <h3> Stylesheet </h3>
        <p> É uma técnica que consiste em utilizar o auxilio do <span> Webpack </span> para nos ajudar em nossas estilizações. De início começamos da mesma forma que antes, criamos um arquivo  styles.css (que será css nomal), e depois importamos ele dentro de onde queremos utilizar. No JSX nós não utilizamos a palavra <span>class</span> igual no css puro. Aqui utilizamos a propriedade <span> className </span>. Dessa forma podemos construir nossos arquivos CSS normal, importamos onde queremos usar, e colocamos as classes. </p>
        <p> Uma outra possível boa prática, é que podemos criar um arquivo css para cada componente que iremos utilizar. Dessa forma você irá perceber, que agora cada componente tem um arquivo dele e um arquivo de sua estilização. </p>
        <p> Ainda existe outra forma de organizarmos ainda mais. Pois dentro da pasta componentes, um componente estará com dois aquivos(botao.tsx, botao.css) por exemplo. A medida que formos cosntruindo 30, 40 componentes, teremos o dobro de arquivo e cada vez mais isso vai dificultando nossa leitura. Baseado nisso, podemos criar uma pasta para cada componente, e dentro dele colocar o componente e sua estilização. Como estará tudo separado, podemos nomear o componente de index, e o css de style.  </p>
        <img src="../../img/reactjs/r19.jpg" alt="">
        <p> OBS: Quando iremos buildar o projeto, ele irá pegar todos os arquivos CSS e juntar em um só, logo, é de boa prática colocarmos nomes de classes único e não repeti-las para evitar possíveis erros. </p>
        <h3> CSS Modules </h3>
        <p> Outra técnica de estilização muito parecida com a vista acima. Criamos um arquivo css nomeado como <span>styles.modules.css</span>, e na hora de importar, importamos nomeando com o nome que quisermos e depois utilizamos da seguinte forma: Supomos que nomeamos de style. basta colocarmos style.nomeDaClasseNoArquivoCss. exemplo: </p>
        <img src="../../img/reactjs/r20.jpg" alt="">
        <p> Dessa forma ele exclui alguns problemas que poderiamos ter com o stylesheet, pois ele muda o nome próprio da class no código fonte, logo não teremos o mesmo problema de conflitos de nomes, não precisamos nos preocupar com nomes repetidos. Dentre o StyleSheet e o CssModules, utilize o <span>CSS Modules</span>.</p>
        <h3> Styled Components </h3>
        <p>Aqui vemos uma outra alternativa ao que estávamos fazendo. Aqui iremos ver uma biblioteca extremamente utilizada no mercado atual, a chamada <a href="https://styled-components.com/" target="_blank">Styled Components</a>. Aqui a ideia é completamente diferente do que vimos anteriormente, porém ela facilita demais a criação de determinados projetos.</p>
        <p> Vamos começar instalando a biblioteca: <span>npm install styled-components</span>. E quando estivermos trabalhando com o typeScript, precisamos instalar seus types, como comando: <span>npm install -D @types/styled-components</span>. A partir daqui a biblioteca estará pronta para ser utilizada. </p>
        <p> Para utilizarmos, primeiramente vamos importar da biblioteca. O segundo passo é criar o nosso 'styled component'. Para isso, vamos criar a constante, e atribuir styled.tagHtmlQueIriaRetornarNormalmente que no nosso exemplo é uma div. A partir daí, basta abrirmos ``, e dentro dela é código css normal. Agora dentro do nosso componente, ao invés de abrirmos e fecharmos uma tag DIV para retornar, abrimos e fechamos o styled component que nomeamos. Abaixo temos um Exemplo para clarear o dito acima: </p>
        <img src="../../img/reactjs/r21.jpg" alt="">
        <p> Dando sequência, aqui abaixo mostramos um exemplo de um styled component dentro de outro styled component.</p>
        <img src="../../img/reactjs/r22.jpg" alt="">
        <p> Em resumo, a partir daqui toda a estilização fica dentro do seu próprio componente. Dando continuidade, conforme formos criando projetos reais, vamos perceber que fica inviavel todos os styled components ficarem localizados em um só lugar como mostramos no exemplo dois.Com o tempo, teremos projetos com dezenas e até centenas de components, então imagine como ficaria ? </p>
        <p> Então como você já deve imaginar, nós iremos separa-los . Podemos criar uma pasta chamada components, e coloca-los lá dentro. No nosso arquivo, apenas imoprtamos os compoennts que formos utilizar.</p>
        <p> Então recapitulando, a primeira forma são todos juntos dentro do mesmo arquivo, a segunda forma é separado cada component em uma pasta component onde depois exportamos e importamos onde iremos utilizar, e temos uma terceira forma.</p>
        <p> Na terceira forma, basicamente criamos um AppStyles.ts (criaremos para todos os componentes, nesse caso botei o app para exemplo, mas poderia ser NavStyles.ts por exemplo.) e dentro desse arquivo, colocaremos todos os styledComponents que serão utilizados dentro daquele componente. </p>
        <p> Dito isto, obviamente a primeira forma é a menos aconselhável. O terceiro método é mais aconselhado pois resume muito o número de 'imports'.</p>
        <h3> Passando Props dinâmicas ao Styled </h3>
        <p> Aqui iremos aprender a adaptar melhor cada componente, pois por exemplo, Os botões do nosso sistema muitas vezes terão o mesmo estilo, e poucas diferencas como verde para acerto e vermelho para error(exemplo ilustrativo). Para isso que vem as props dinâmicas, para que possamos reutilizar e reaproveitar o código.</p>
        <p> No exemplo abaixo mostraremos o exemplo desse botão, que iremos passar uma prop SMALL e uma prop de bgColor. </p>
        <img src="../../img/reactjs/r23.jpg" alt="">
        <img src="../../img/reactjs/r24.jpg" alt="">
        <p> Dessa forma passamos estilizações dinâmicas para dentro do styled-components, porém como estamos usando typescript, precisamos typalas para remover o error. Exemplo: </p>
        <img src="../../img/reactjs/r25.jpg" alt="">
        <h3> Estilizando Filhos Componentes </h3>
        <p> Dentro de um componente container por exemplo, além de estilziarmos o container em si, também podemos estilizar tudo que possui dentro dele, com css normal. Exemplo Abaixo: </p>
        <img src="../../img/reactjs/r26.jpg" alt="">
        <h3> Responsividade com Styled Components</h3>
        <p> A parte da responsividade funciona da mesma forma com que fariamos com o CSS normal, utilizando as <span>@mediaQueries</span>.</p>
        <p> Para continuarmos falando de Estilizações, passamos para próximos passos estudando os frameworks, nos links abaixo: </p>
        <ul>
            <li> <a href="#"> Bootstrap</a> </li>
            <li><a href="#"> Sass</a> </li>
            <li><a href="#">Tailwind </a> </li>
        </ul>
        <h1 id="cv"> Ciclo de Vida, Req's Hooks Avançados</h1>
        <p> Aqui iremos aprender um dos principais conceitos do ReactJs que são os seus <span>Ciclos de Vida</span>. É igual o nosso ciclo de vida, nascemos, crescemos e morremos. Um componente do React tem algo extremamente similar a esse conceito, que é o seguinte: Um componente do react(que começa no principal, app), possui seu ciclo de vida. Em cada etapa do ciclo de vida de um componente existe uma ação que é executada , na qual o programador pode interferir colocando códigos dentro desta ação.</p>
        <p> Primeiro o componente é criado na memória e depois ele é renderizado. Ao ser criado na memória é a sua primeira etapa. Ao ser renderizado ele vai para a segunda etapa. Enquanto ele ficar disponível em tela significa que ele esta "vivo", e a cada alteração de state que já vimos (useState) é uma nova etapa do ciclo de vida, e sua ultima etapa é a sua "morte", quando ele é removido. Dito isto, a cada alteração dessa etapa  podemos colocar um código 'atrelado'. Por exemplo, 'quando esse componente for renderizado em tela, execute esse código' ou então 'Quando determinado componente for encerrado, execute esse código'. E por aí vai. </p>
        <p> Indo para a prática, aqui começamos a aprender sobre o <span>useEffect</span>. O useEffect serve para intervir o meio de um processo de 'troca de ciclo de vida'. Imagine o cenário que exista um nome em tela (name), e ao apertar um botão chamamos uma função, que altera o estado desse nome para qualquer oturo nome por exemplo. </p>
        <p> O useEffect recebe dois parâmetros, uma função e um Array. Dentro da função colocamos o trecho de código para ser executado quando o componente for criado ou quando ele for alterado. Se não colocarmos nada dentro do array, ele irá executar a função assim que o componente estiver disponível(for renderizado). Já dentro do Array, colocamos o que o useEffect deve monitorar. Por exemplo: Se não colocarmos a variávem name do exemplo acima, assim que ela for alterada ele também irá executar a função vinda do primeiro parâmetro. Exemplo simples abaixo: </p>
        <img src="../../img/reactjs/r27.jpg" alt="">
        <h3> UseEffect na prática </h3>
        <p> Abaixo temos um simples evento no qual Digitamos um camo Name, Last name, e o useEffect pega, e preenche o campo FullName, juntando os dois Campos. </p>
        <img src="../../img/reactjs/r28.jpg" alt="">
        <h2> Requisições com React </h2>
        <h3> Req GET  (FETCH)</h3>
        <p> Quando temos comunicação com o backend em aplicações REACT ela é feita mais ou menos da mesma forma que com o JS. Na qual podemos utilizar por exemplo o método <span>fetch().then().then() </span> igual vimos antes. Como o exemplo abaixo, que ao clicar no botão ele faz uma requisição a uma API utilizando o método GET, para retornar seus filmes.  </p>
        <img src="../../img/reactjs/r29.jpg" alt="">
        <p> Porém como estamos utilizando TypeScript o código acima deve ser typado, para manter o "padrão".</p>
        <h3> Req GET (ASYNC/AWAIT)</h3>
        <p> O fetch roda de forma assíncrona, ele não espera, o que está embaixo da função fetch, vai ser executada sem esperar a resposta. Mas e se o que tiver embaixo depender da resposta do fetch ? Para isso temos a opção <span>Async/Await</span>, que irá esperar a resposta para depois continuar. Temos o exemplo abaixo substituindo do exemplo anterior: </p>
        <img src="../../img/reactjs/r30.jpg" alt="">
        <h3> Lidando com Loading: </h3>
        <p> Quando trabalhamos com requisições a api's, temos um 'delay' dessa requisição, que da um leve pisco na tela. Porém essa requisição por N motivos pode levar mais tempo que o esperado. Logo, é importante exibir para o usuário alguma coisam, para ele nao ficar vendo uma tela em branco por exemplo. Aí que entra o <span>Loading</span>. Para lidarmos com Loading, podemos criar uma state booleana que começará como false. Quando ele começar, flipa para true, e quando acabar volta para false. Simples assim. Exemplo abaixo:  </p>
        <p>Dentro da requisição: </p>
        <img src="../../img/reactjs/r31.jpg" alt="">
        <p>Mostrando na tela: </p>
        <img src="../../img/reactjs/r32.jpg" alt="">
        <p> Em caso confuso :  <a href="https://alunos.b7web.com.br/curso/reactjs/react-lidando-com-loading " target="_blank">Aula Loading - Privada </a></p>
        <h3> Erros na Requisição: </h3>
        <p> Precisamos obrigatóriamente colocar uma tratação, pois caso contrário ficará aparecendo o loading eterno para o usuário. </p>
        <p> Quando estamos trabalhando com o Async/Await, usamos o <span>Try/Catch</span>:</p>
        <img src="../../img/reactjs/r33.jpg" alt="">
        <p> Quando estamos trabalhando com o Fetch, usamos o <span>.catch((e)=>{})</span></p>
        <img src="../../img/reactjs/r34.jpg" alt="">
        <h3> Requisições POST </h3>
        <p> Aqui entraremos em um assunto de extrema importância, pois é através das requisições POSTS que iremos enviar dados do front para o back-end. Ao preenchermos as informações com os dados de um usuário por exemplo, é através da requisição post que esse user é enviado para ser tratado na API do BACK. </p>
        <p> Para realizar essa requisição, primeiramente pegamos dos campos todos os dados que iremos trabalhar(como já vimos em exemplos acima trabalhando com <span>onChange</span>. Em seguida, começamos a trabalhar com o envio via POST, na qual segue o mesmo princípio porém temos adições de informações. Primeiramente conferimos se os dados existem. Em seguida começamos. O fetch geralmente possui dois parâmetros. Nos exemplos acima, utilizamos apenas o primeiro parâmetro, que é a URL da requisição que enviaremos. Porém em req via POST, usaremos o segundo parâmetro que é um objeto. Nesse objeto teremos: </p>
        <ul>
            <li>method: 'POST'</li>
            <li>body: JSON.stringfy({dados})// </li>
            <li>headers: {} // Geralmente avisamos o content Type (Json)</li>
        </ul>
        <p> Exemplo Abaixo: </p>
        <img src="../../img/reactjs/r35.jpg" alt="">
        <h3> Boas Práticas Req's</h3>
        <p> Da forma que vimos acima está tudo funcionando. Porém pensando em futuras manutenções, fica complicado saber onde existem requisições dentro da sua aplicação. Para solucionar isso, é uma boa prática colocarmos todas as requisições dentro de um só lugar. Dessa forma futuramente quando precisarmos mudar a API, já saberemos em qual lugar do código estará concentrado todas as requisições.</p>
        <p> Para fazer isso, criamos um OBJETO, com várias funções, cada função será uma requisição. Exemplo abaixo: </p>
        <img src="../../img/reactjs/r36.jpg" alt="">
        <img src="../../img/reactjs/r37.jpg" alt="">
        <p> Dessa forma, o sistema fica mais simples. Se algum dia o link da API mudar, não iremos precisar andar pelo código inteiro procurando onde está sendo feita as requisições pois todas estarão em um lugar específico.</p>
        <h3> Axios </h3>
        <p> O Fetch é o processo natural de fazer requisições no JS, porém temos o Axios, que é uma biblioteca que chegará ao mesmo resultado só que caminhando um caminho mais 'fácil'. Primeiramente precisamos instala-la com o comando: <span>npm install axios</span>. Assim como tudo, precisamos importa-la. </p>
        <p> No Axios, a response por padrão já vem convertida para JSON. Abaixo segue dois exemplos da forma simples de requisições via Axios: </p>
        <img src="../../img/reactjs/r38.jpg" alt="">
        <p> Para mais informações podemos consultar a <a href="https://axios-http.com/docs/intro" target="_blank"> documentação do Axios</a>. </p>
        <h2> Reducers </h2>
        <p> Reducer são basicamente um complemento do State. Quando queremos salvar uma informação e depois altera-la, utilizamos o já visto <span>useState</span>. O Reducer tem o mesmo papel do State, porém ele só é indicado quando temos problemas mais complexos para resolver. Quando falamos em complexo, é que na verdade o <span>useState</span> trabalha com uma variável, já o <span>useReducer</span> tem a capacidade de monitorar várias, dessa forma o código fica menor e mais limpo. Com o tempo iremos estudar também o <span>useContext</span> no qual irá funcionar muito bem trabalhando com o reducer.</p>
        <p> Quando usamos o STATE, temos o nome do state, e o setNomeDoState para atribuir um novo valor. </p>
        <p> No Reducer, temos a seguinte estrutura:  </p>
        <p> const <span>[state, dispatch</span> = useReducer <span>(reducer,initialState)</span>.</p>
        <ul>
            <li> <span>STATE </span> - É parecido com o useState, é um estado que gerencia vários estados pequenos. A diferença é que aqui eles são gerenciados na mesma funcionalidade. </li>
            <li> <span>DISPATCH</span> - É a função a ser chamada dentro do JSX, com o argumento do nome da action, para ser executada dentro da função Reducer. </li>
            <li> <span> REDUCER</span> - É uma função que vai armazenar cada ação que pode ser tomada para alterar os estados. Em um contador por exemplo, pode ter o ADD, REMOVE, RESET. Essa função recebe por padrão dois parâmetros <span>state , action</span>. Geralmente utilizamos <span>SWITCH</span> para escolher.</li>
            <li> <span>INITIAL STATE </span> - É igual o parâmetro do useState. É o valor inicial de cada estado a ser monitorado pelo reducer. Podendo ser diretamente um 0 por exemplo, porém como estamos usando reducer, geralmente iremos mapear mais de um estado, e para isso colocamos um objeto, com o estado inicial de cada um. </li>
        </ul>
        <p> Ou seja, dentro do código, começamos criando um objeto com os estados a serem monitorados (initialState), e em seguida criamos a função reducer, onde receberemos o state, e colocaremos todas as actions possíveis para tal ação. Por exemplo, colocamos um initial state um objeto com um count. { count: 0 }</p>
        <p> Dentro do nosso JSX, para exibir esse count, utilizamos o state.count. Assim apenas o dispatch estará faltando para o hook estar 100% em uso. Básicamente o dispatch irá disparar uma ação para o reducer. Dentro do evento no jsx, seja ele onCLick, onCHange, onSubmit, ao invés de chamarmos uma função diretamente, nós chamamos : () => dispatch('nomeDaAçãoEscritaNoReducer').</p>
        <p> Para melhor compreendermos, temos um exemplo com o contador. Toda a função que utilizarmos no useReducer, por padrão ela vem com dois parâmetros (state, action). Através da ação desse action que iremos trabalhar o que fazer. </p>
        <img src="../../img/reactjs/r39.jpg" alt="">
        <img src="../../img/reactjs/r40.jpg" alt="">
        <h1 id="rv6"> React Router (v6)</h1>
        <h2> O que é React Router? </h2>
        <p> A partir desse momento poderemos começar a trabalhar de forma mais profissional, pois aqui aprenderemos a trabalhar com a paginação do React. Isso tudo será possível através de uma biblioteca chamada <span>ReactRouter V6</span>, e para isso, basta utilizarmos o comando: <span> npm install -react-router-dom</span>. Aqui ela já vem por padrão com suporte para TypeScript. Para o React Router funcionar, precisamos criar um esqueleto, um escopo geral do react router na aplicação. Para isso vamos no main.tsx ou index.tsx, importamos o browser Router, e colocamos nossa aplicação dentro dele. Dessa forma, todas as rotas só funcionarão se estiverem dentro dele. </p>
        <img src="../../img/reactjs/r41.jpg" alt="">
        <p> A partir desse momento, estamos prontos para criar nossas rotas de forma simples. Basta importarmos o <span>Routes e o Route </span>.</p>
        <img src="../../img/reactjs/r42.jpg" alt="">
        <h3>Pag 404</h3>
        <p> Por padrão, precisamos criar um componente com uma página 404, para caso o usuário erre apareça algo. Para isso criamos uma rota dinâmica, na qual o router irá procurar todas as rotas existentes, e caso seja algo diferente ele irá para essa rota coringa. Em resumo, qualquer rota que for digitada que não estiver especificada em nossas rotas, cairá na página 404.</p>
        <img src="../../img/reactjs/r43.jpg" alt="">
        <h3> Links </h3>
        <p> Obviamente não iremos navegar pela nossa aplicação digitando os endpoints exatos, e sim através de botões em tela. Podemos imaginar que se colocarmos uma tag A com a rota em especifico. ex: ahref: /sobre/pedro irá funcionar, e na verdade, irá mesmo. Porém  desta forma ele irá recarregar a página inteira de uma vez só, e assim estará descartando todo o poder do react(que é de renderizar apenas o que é alterado). Para solucionar isso, precisamos aprender a forma certa que é ao invés da tag A utilizar o <span>LINK</span> importado do prórpio reactRouter.</p>
        <img src="../../img/reactjs/r44.jpg" alt="">
        <h3> Rotas Valores Dinâmicos </h3>
        <p> Rotas dinâmicas são de extrema importância, pois imagine que tenhamos uam tela para os dados de cada usuário, e que também tenhamos mil usuários no banco. Não ficaria viável digitar as mil rotas a mão. Para isso entramos nas nossas <span>rotas dinâmicas</span>. Se já estudou os resumos de <a href="../back-end/nodejs.html">NodeJS</a> funciona do mesmo jeito, colocando :identificador. E o próprio componente também se tornará dinâmico, uma página genérica que irá se moldar de acordo com o usuário passado por exemplo. No exemplo abaixo temos uma rota que passamos um parâmetro e os recebemos com a ajuda do hook <span>useParam</span>.</p>
        <p> const params = <span>useParams()</span></p>
        <img src="../../img/reactjs/r45.jpg" alt="">
        <img src="../../img/reactjs/r46.jpg" alt="">
        <h3> Redirecionamento de Rotas</h3>
        <p> Redirecionamento de rotas é basicamente quando queremos 'voltar' para a página anterior, ou voltar para a página home. Para realizar essa ação utilizamos outro hook do reactRouter, chamado <span>useNavigate()</span>. </p>
        <p>const navigate = useNavigate()</p>
        <p> Através desse hook, podemos voltar para a página aberta anteriormente (-1), e também podemos direcionar para alguma página em específico. Os dois exemplos estão citados abaixo. </p>
        <img src="../../img/reactjs/r47.jpg" alt="">
        <p> No segundo exemplo, não estaremos voltando, e sim INDO para uma página específica. E tudo isso é feito baseado na intelogência do ReactRouter. Vale ressaltar, que ele não precisa ser utilizado especificamente sobre ação de botões. Por exemplo, ao verificar um login, caso seja aprovado, voce precisará redirecionar, então, utilize o hook.</p>
        <h3> Parâmetros de Query</h3>
        <p> Aqui iremos realizar o processo de leitura de QueryString, e para isso utilizaremos o usode mais um hook, <span>useSearchParams</span>. </p>
        <a href="https://alunos.b7web.com.br/curso/reactjs/parametros-de-query">VERIFIACR A AULA PAGA </a>
        <h3> Rotas Privadas</h3>
        <p> Aqui é um dos passos mais importantes do entendimento do ReactRouter. Por exemplo, em um sistema com login, algumas páginas só serão acessíveis caso o usuário esteja logado, já outras páginas podem ser 'abertas' a todos.  Aqui será mostrado o processo para criar uma rota privada, pois o processo por completo precisaremos dos conhecimentos em <span>back-end</span>. </p>
        <p> Existe basicamente duas formas para realizar esse processo e aqui abaixo ambas serão apresentadas. Uma será a forma para aprender e a segunda será a forma para ficar 'profissionalizado'.  </p>
        <p> Uma rota por padrão nunca será uma rota privada, logo, para privar precisamos criar esse recurso. E como podemos fazer isso? Supomos que a rota SOBRE seja privada. Podemos redirecionar para ela, lá verificar, e caso não esteja logado, redirecionamos para outra página. Porém não seria eficiente pois processo de verificação não é instantâneo e seria repetitivo, pois em todas as páginas privadas teremos que repetir o mesmo código. </p>
        <p> Sabendo isso podemos definir que uma boa forma de lidar, é nunca tratar uma rota privada na página na qual ela será aberta, mas sim antes disso. E como ? Criamos um novo componente chamado requereAuth.tsx (porexemplo). A partir daí, nossas rotas privadas ficarão embrulhadas dentro do componente requireAuth, ou seja: ele irá renderizar o require auth e o próprio irá decidir se renderiza a sobre ou não. (Como no exemplo abaixo).</p>
        <img src="../../img/reactjs/r48.jpg" alt="">
        





        <h3> Rotas em Componente</h3>
        <h3>Rotas em Objeto</h3>

        <h1 id="capi"> Context API </h1>
        <h1 id="redux"> Redux </h1>


    </main>
</body>
</html>